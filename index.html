<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Micro-Hazard Dashboard (Heat & Air Quality)</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    #info {
      position: absolute;
      top: 10px;
      right: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.3);
      max-width: 280px;
      z-index: 1000;
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.3);
      z-index: 1000;
    }
    #legend {
      position: absolute;
      bottom: 50px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: none;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 3px 0;
      font-size: 12px;
    }
    .legend-color {
      width: 20px;
      height: 12px;
      margin-right: 5px;
      border: 1px solid #333;
    }
    #info h2 {
      margin: 0 0 8px;
      font-size: 16px;
    }
    #info p {
      margin: 4px 0;
      font-size: 14px;
    }
    #loading {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 6px 10px;
      border-radius: 5px;
      font-size: 13px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
      z-index: 1000;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <div id="controls">
    <h3 style="margin: 0 0 10px; font-size: 14px;">Navigation</h3>
    <div style="margin-bottom: 12px; position: relative;">
      <input type="text" id="locationSearch" placeholder="Enter city, state or address..." style="padding: 12px 16px; width: 240px; border: 2px solid #e1e5e9; border-radius: 8px; font-size: 14px; font-family: 'Inter', sans-serif; transition: all 0.2s ease; outline: none; background: rgba(255, 255, 255, 0.9);" onfocus="this.style.borderColor='#007cbb'; this.style.boxShadow='0 0 0 3px rgba(0, 124, 187, 0.1)'" onblur="setTimeout(() => {this.style.borderColor='#e1e5e9'; this.style.boxShadow='none'; hideAutocomplete();}, 200)">
      <div id="autocompleteResults" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid #e1e5e9; border-top: none; border-radius: 0 0 8px 8px; max-height: 200px; overflow-y: auto; display: none; z-index: 1001; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);"></div>
      <button id="searchLocation" style="padding: 12px 16px; background: linear-gradient(135deg, #28a745, #20c997); color: white; border: none; border-radius: 8px; cursor: pointer; margin-left: 8px; font-weight: 500; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(40, 167, 69, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(40, 167, 69, 0.3)'">Search</button>
    </div>
    <button id="focus-us" style="padding: 12px 16px; background: linear-gradient(135deg, #007cbb, #0056b3); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 14px; transition: all 0.2s ease; width: 100%; box-shadow: 0 2px 8px rgba(0, 124, 187, 0.3);" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0, 124, 187, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 124, 187, 0.3)'">Focus on US Territory</button>
  </div>

  <div id="legend">
    <h4 style="margin: 0 0 8px; font-size: 12px;" id="legendTitle">Legend</h4>
    <div id="legendContent"></div>
  </div>

  <div id="info">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
      <h2 style="margin: 0; font-size: 16px;">Safety Dashboard</h2>
      <button id="toggleDashboard" style="background: #007cbb; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">Minimize</button>
    </div>
    
    <div id="safetyStatus" style="padding: 6px; border-radius: 4px; margin-bottom: 8px; font-weight: bold; text-align: center; font-size: 14px; transition: all 0.3s ease;">
      Click on US territory for environmental data
    </div>
    
    <div id="dashboardContent">
      <div class="hazard-summary" style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 10px;">
        <div style="background: #f8f9fa; padding: 6px; border-radius: 4px; text-align: center;">
          <div style="font-size: 11px; color: #666;">Heat Index</div>
          <div style="font-weight: bold; color: #E74C3C;"><span id="hi">––</span>°F</div>
        </div>
        <div style="background: #f8f9fa; padding: 6px; border-radius: 4px; text-align: center;">
          <div style="font-size: 11px; color: #666;">UV Index</div>
          <div style="font-weight: bold; color: #F39C12;"><span id="uv">––</span></div>
        </div>
        <div style="background: #f8f9fa; padding: 6px; border-radius: 4px; text-align: center;">
          <div style="font-size: 11px; color: #666;">Air Quality</div>
          <div style="font-weight: bold; color: #8E44AD;"><span id="pm25">––</span> µg/m³</div>
        </div>
        <div style="background: #f8f9fa; padding: 6px; border-radius: 4px; text-align: center;">
          <div style="font-size: 11px; color: #666;">Wind</div>
          <div style="font-weight: bold; color: #3498DB;"><span id="wind">––</span> mph</div>
        </div>
      </div>
      
      <details style="margin: 4px 0;">
        <summary style="cursor: pointer; font-size: 12px; font-weight: bold; color: #E67E22;">🔥 Fire & Weather Risk</summary>
        <div style="padding: 4px 0; font-size: 11px;">
          <div>Fire Risk: <span id="fireRisk" style="font-weight: bold;">––</span></div>
          <div>Humidity: <span id="humidity">––</span>%</div>
          <div>Precipitation: <span id="precipitation">––</span> mm</div>
        </div>
      </details>
      
      <details style="margin: 4px 0;">
        <summary style="cursor: pointer; font-size: 12px; font-weight: bold; color: #2980B9;">🌊 Environmental</summary>
        <div style="padding: 4px 0; font-size: 11px;">
          <div>Visibility: <span id="visibility">––</span> miles</div>
          <div>Cloud Cover: <span id="cloudCover">––</span>%</div>
          <div>Pressure: <span id="pressure">––</span> hPa</div>
        </div>
      </details>
      
      <details style="margin: 4px 0;">
        <summary style="cursor: pointer; font-size: 12px; font-weight: bold; color: #95A5A6;">❄️ Temperature & Snow</summary>
        <div style="padding: 4px 0; font-size: 11px;">
          <div>Temperature: <span id="temperature">––</span>°F</div>
          <div>Snow Depth: <span id="snowDepth">––</span> cm</div>
        </div>
      </details>
    </div>
    
    <div id="minimizedView" style="display: none;">
      <div style="display: flex; gap: 8px; font-size: 11px;">
        <span>🌡️<span id="hiMin">––</span></span>
        <span>☀️<span id="uvMin">––</span></span>
        <span>🌫️<span id="pm25Min">––</span></span>
        <span>💨<span id="windMin">––</span></span>
      </div>
    </div>
    
    <p style="font-size: 10px; color: #666; margin: 8px 0 0; text-align: center;">
      Click any location for detailed safety data
    </p>
  </div>
  <div id="loading" style="display:none">Loading…</div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>

  <script>
    // ─────────────────────────────────────────────────────────────────────────────
    // 1. Initialize map
    // ─────────────────────────────────────────────────────────────────────────────
    const map = L.map("map", {
      // Focus on Continental US bounds only
      maxBounds: [
        [20.0, -130.0], // Southwest corner (southern California/Texas)
        [50.0, -65.0]   // Northeast corner (Maine/Minnesota)
      ],
      maxBoundsViscosity: 1.0,
      minZoom: 3,
      maxZoom: 12
    }).setView([39.5, -98.35], 4); // Default: center of contiguous USA

    // Add standard OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap contributors | Environmental data via Open-Meteo'
    }).addTo(map);

    // Simple US-focused map without complex boundary loading

    let marker = null;
    let currentOverlay = null;

    // Dashboard toggle functionality
    document.getElementById('toggleDashboard').addEventListener('click', function() {
      const content = document.getElementById('dashboardContent');
      const minimized = document.getElementById('minimizedView');
      const button = this;
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        minimized.style.display = 'none';
        button.textContent = 'Minimize';
      } else {
        content.style.display = 'none';
        minimized.style.display = 'block';
        button.textContent = 'Expand';
      }
    });

    // Utility to show/hide loading indicator
    function setLoading(show) {
      document.getElementById("loading").style.display = show ? "block" : "none";
    }

    // Color schemes for different hazard types
    const colorSchemes = {
      heat: {
        title: "Heat Index (°F)",
        ranges: [
          { min: 0, max: 80, color: "#00ff00", label: "Safe (< 80°F)" },
          { min: 80, max: 90, color: "#ffff00", label: "Caution (80-90°F)" },
          { min: 90, max: 105, color: "#ff8800", label: "Extreme Caution (90-105°F)" },
          { min: 105, max: 130, color: "#ff0000", label: "Danger (105-130°F)" },
          { min: 130, max: 200, color: "#8b0000", label: "Extreme Danger (>130°F)" }
        ]
      },
      uv: {
        title: "UV Index",
        ranges: [
          { min: 0, max: 2, color: "#00ff00", label: "Low (0-2)" },
          { min: 2, max: 5, color: "#ffff00", label: "Moderate (3-5)" },
          { min: 5, max: 7, color: "#ff8800", label: "High (6-7)" },
          { min: 7, max: 10, color: "#ff0000", label: "Very High (8-10)" },
          { min: 10, max: 20, color: "#8b0000", label: "Extreme (11+)" }
        ]
      },
      pm25: {
        title: "PM₂.₅ (µg/m³)",
        ranges: [
          { min: 0, max: 12, color: "#00ff00", label: "Good (0-12)" },
          { min: 12, max: 35.4, color: "#ffff00", label: "Moderate (12-35)" },
          { min: 35.4, max: 55.4, color: "#ff8800", label: "Unhealthy SG (35-55)" },
          { min: 55.4, max: 150.4, color: "#ff0000", label: "Unhealthy (55-150)" },
          { min: 150.4, max: 500, color: "#8b0000", label: "Hazardous (150+)" }
        ]
      },
      wind: {
        title: "Wind Speed (mph)",
        ranges: [
          { min: 0, max: 15, color: "#00ff00", label: "Light (0-15 mph)" },
          { min: 15, max: 25, color: "#ffff00", label: "Moderate (15-25 mph)" },
          { min: 25, max: 39, color: "#ff8800", label: "Strong (25-39 mph)" },
          { min: 39, max: 54, color: "#ff0000", label: "Gale (39-54 mph)" },
          { min: 54, max: 200, color: "#8b0000", label: "Storm (54+ mph)" }
        ]
      }
    };

    // Generate strategic grid points for colormap overlay
    function generateGridPoints(bounds, resolution = 20) {
      const points = [];
      // Create a more focused grid that covers key areas
      const latRange = bounds.north - bounds.south;
      const lonRange = bounds.east - bounds.west;
      
      // Only create points if the area is reasonable size
      if (latRange > 0.1 && lonRange > 0.1) {
        const latStep = latRange / Math.min(resolution, 8); // Limit to max 8x8 grid
        const lonStep = lonRange / Math.min(resolution, 8);
        
        for (let i = 1; i < Math.min(resolution, 8); i++) {
          for (let j = 1; j < Math.min(resolution, 8); j++) {
            const lat = bounds.south + (latStep * i);
            const lon = bounds.west + (lonStep * j);
            points.push({ lat, lon });
          }
        }
      }
      return points;
    }

    // Get color for value based on scheme
    function getColorForValue(value, scheme) {
      for (const range of scheme.ranges) {
        if (value >= range.min && value < range.max) {
          return range.color;
        }
      }
      return scheme.ranges[scheme.ranges.length - 1].color;
    }

    // Create and display legend
    function showLegend(layerType) {
      const legend = document.getElementById("legend");
      const title = document.getElementById("legendTitle");
      const content = document.getElementById("legendContent");
      
      if (layerType === "none") {
        legend.style.display = "none";
        return;
      }
      
      const scheme = colorSchemes[layerType];
      title.textContent = scheme.title;
      content.innerHTML = "";
      
      scheme.ranges.forEach(range => {
        const item = document.createElement("div");
        item.className = "legend-item";
        item.innerHTML = `
          <div class="legend-color" style="background-color: ${range.color}"></div>
          <span>${range.label}</span>
        `;
        content.appendChild(item);
      });
      
      legend.style.display = "block";
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 2. Helper: Compute Heat Index (°F) from T (°F) and RH (%)
    // NOAA formula: returns HI in °F
    // Source: https://www.wpc.ncep.noaa.gov/html/heatindex_equation.shtml
    // ─────────────────────────────────────────────────────────────────────────────
    function computeHeatIndex(tF, rh) {
      // Only valid if tF >= 80°F and RH >= 40%; otherwise return tF
      if (tF < 80 || rh < 40) return tF.toFixed(1);

      const T = tF,
        R = rh;
      const HI =
        -42.379 +
        2.04901523 * T +
        10.14333127 * R -
        0.22475541 * T * R -
        6.83783e-3 * T * T -
        5.481717e-2 * R * R +
        1.22874e-3 * T * T * R +
        8.5282e-4 * T * R * R -
        1.99e-6 * T * T * R * R;
      return HI.toFixed(1);
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 3. Helper: Map PM2.5 to simplistic category
    // Based on US EPA breakpoints:
    //  0–12 → Good; 12.1–35.4 → Moderate; 35.5–55.4 → Unhealthy for Sensitive Groups; etc.
    // ─────────────────────────────────────────────────────────────────────────────
    function categorizePM25(val) {
      if (val <= 12) return "Good";
      if (val <= 35.4) return "Moderate";
      if (val <= 55.4) return "Unhealthy (SG)";
      if (val <= 150.4) return "Unhealthy";
      if (val <= 250.4) return "Very Unhealthy";
      return "Hazardous";
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 4. Helper: Categorize UV Index and provide safety recommendations
    // ─────────────────────────────────────────────────────────────────────────────
    function categorizeUV(val) {
      if (val <= 2) return { level: "Low", warning: "🟢 Minimal risk" };
      if (val <= 5) return { level: "Moderate", warning: "🟡 Wear sunscreen" };
      if (val <= 7) return { level: "High", warning: "🟠 Seek shade, wear protection" };
      if (val <= 10) return { level: "Very High", warning: "🔴 Avoid sun 10AM-4PM" };
      return { level: "Extreme", warning: "🟣 DANGER: Stay indoors" };
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 5. Helper: Assess heat safety based on Heat Index
    // ─────────────────────────────────────────────────────────────────────────────
    function assessHeatSafety(hi) {
      if (hi < 80) return { level: "Safe", warning: "" };
      if (hi < 90) return { level: "Caution", warning: "🟡 Stay hydrated" };
      if (hi < 105) return { level: "Extreme Caution", warning: "🟠 Limit outdoor activity" };
      if (hi < 130) return { level: "Danger", warning: "🔴 Heat exhaustion likely" };
      return { level: "Extreme Danger", warning: "🟣 HEAT STROKE IMMINENT" };
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 6. Helper: Calculate overall safety status
    // ─────────────────────────────────────────────────────────────────────────────
    function calculateSafetyStatus(hi, uv, pm25, wind, visibility) {
      const risks = [];
      
      if (hi >= 105) risks.push("Heat Danger");
      if (uv > 7) risks.push("UV Extreme");
      if (pm25 > 55.4) risks.push("Air Quality Unhealthy");
      if (wind > 39) risks.push("High Winds");
      if (visibility < 3) risks.push("Low Visibility");
      
      if (risks.length === 0) return { status: "SAFE", color: "#4CAF50", message: "Conditions are safe" };
      if (risks.length <= 2) return { status: "CAUTION", color: "#FF9800", message: `Watch for: ${risks.join(", ")}` };
      return { status: "DANGER", color: "#F44336", message: `Multiple hazards: ${risks.join(", ")}` };
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 7. Fetch safety data - switches to demo mode if API limit reached
    // ─────────────────────────────────────────────────────────────────────────────
    async function fetchClimateData(lat, lon) {
      // Show loading
      setLoading(true);

      const proxyUrl = `/api/weather?lat=${lat}&lon=${lon}`;

      try {
        console.log("Fetching weather data for:", lat, lon);
        
        const response = await fetch(proxyUrl);

        if (!response.ok) {
          // If API fails (likely quota exceeded), show demonstration data
          if (response.status === 500 || response.status === 401) {
            console.log("API quota likely exceeded, showing demo data");
            setLoading(false);
            return generateDemoData(lat, lon);
          }
          throw new Error(`API request failed: ${response.status}`);
        }

        const data = await response.json();
        setLoading(false);
        
        console.log("API Response:", data);
        console.log("Mapped data:", { 
          hi: data.heat_index, 
          pm25: data.pm25, 
          uv: data.uv_index, 
          wind: data.wind_speed, 
          visibility: data.visibility 
        });

        return { 
          hi: data.heat_index, 
          pm25: data.pm25, 
          uv: data.uv_index, 
          wind: data.wind_speed, 
          visibility: data.visibility 
        };
      } catch (err) {
        setLoading(false);
        console.log("API unavailable, showing demo data");
        return generateDemoData(lat, lon);
      }
    }

    // Generate realistic demo data based on location
    function generateDemoData(lat, lon) {
      // Simulate realistic values based on geographic patterns
      const tempBase = 70 + (lat < 40 ? 15 : 0) + (lat > 50 ? -10 : 0);
      const humidity = 45 + Math.random() * 30;
      const heatIndex = computeHeatIndex(tempBase + Math.random() * 20, humidity);
      
      return {
        hi: heatIndex,
        pm25: 8 + Math.random() * 25, // Typical range
        uv: Math.max(0, 3 + Math.random() * 8), // 0-11 scale
        wind: 5 + Math.random() * 15, // mph
        visibility: 8 + Math.random() * 7 // miles
      };
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // Calculate overall safety status based on all environmental factors
    // ─────────────────────────────────────────────────────────────────────────────
    function calculateSafetyStatus(heatIndex, uvIndex, pm25, windSpeed, visibility) {
      let riskScore = 0;
      let warnings = [];

      // Heat Index assessment
      if (heatIndex >= 130) {
        riskScore += 4; warnings.push("Extreme heat danger");
      } else if (heatIndex >= 105) {
        riskScore += 3; warnings.push("Heat danger");
      } else if (heatIndex >= 90) {
        riskScore += 2; warnings.push("Heat caution");
      }

      // UV Index assessment
      if (uvIndex >= 11) {
        riskScore += 3; warnings.push("Extreme UV");
      } else if (uvIndex >= 8) {
        riskScore += 2; warnings.push("Very high UV");
      } else if (uvIndex >= 6) {
        riskScore += 1; warnings.push("High UV");
      }

      // Air Quality assessment
      if (pm25 >= 150) {
        riskScore += 4; warnings.push("Hazardous air quality");
      } else if (pm25 >= 55) {
        riskScore += 3; warnings.push("Unhealthy air");
      } else if (pm25 >= 35) {
        riskScore += 2; warnings.push("Poor air quality");
      } else if (pm25 >= 12) {
        riskScore += 1; warnings.push("Moderate air quality");
      }

      // Wind assessment
      if (windSpeed >= 54) {
        riskScore += 3; warnings.push("Storm-force winds");
      } else if (windSpeed >= 39) {
        riskScore += 2; warnings.push("Gale-force winds");
      } else if (windSpeed >= 25) {
        riskScore += 1; warnings.push("Strong winds");
      }

      // Determine overall status
      if (riskScore >= 8) {
        return { status: "EXTREME RISK", color: "#8B0000", message: warnings.join(", ") };
      } else if (riskScore >= 5) {
        return { status: "HIGH RISK", color: "#FF0000", message: warnings.join(", ") };
      } else if (riskScore >= 3) {
        return { status: "MODERATE RISK", color: "#FF8800", message: warnings.join(", ") };
      } else if (riskScore >= 1) {
        return { status: "LOW RISK", color: "#FFD700", message: warnings.join(", ") };
      } else {
        return { status: "SAFE", color: "#28A745", message: "Environmental conditions are favorable" };
      }
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // Check if coordinates are within US boundaries using Census data
    // ─────────────────────────────────────────────────────────────────────────────
    function isWithinUSBoundaries(lat, lon) {
      // Always allow Continental US coordinates where we have data coverage
      if (lat >= 24.0 && lat <= 49.0 && lon >= -125.0 && lon <= -66.0) return true;
      
      // Allow Alaska and Hawaii coordinates for comprehensive coverage
      if (lat >= 54.0 && lat <= 72.0 && lon >= -180.0 && lon <= -129.0) return true;
      if (lat >= 18.0 && lat <= 23.0 && lon >= -162.0 && lon <= -154.0) return true;
      
      return false;
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 8. Place (or move) marker & update comprehensive safety info panel
    // ─────────────────────────────────────────────────────────────────────────────
    function updateAt(lat, lon) {
      // Check if location is within US boundaries
      if (!isWithinUSBoundaries(lat, lon)) {
        alert("Environmental data is only available within US boundaries");
        return;
      }

      // Move map & marker
      map.setView([lat, lon], 12);
      if (marker) marker.setLatLng([lat, lon]);
      else marker = L.marker([lat, lon]).addTo(map);

      // Fetch and update dashboard with real environmental data
      fetchClimateData(lat, lon).then(data => {
        console.log("Updating dashboard with:", data);
        
        // Simple direct updates
        document.getElementById("hi").textContent = data.hi ? data.hi.toFixed(1) : "–";
        document.getElementById("uv").textContent = data.uv ? data.uv.toFixed(1) : "–";
        document.getElementById("pm25").textContent = data.pm25 ? data.pm25.toFixed(1) : "–";
        document.getElementById("wind").textContent = data.wind ? data.wind.toFixed(1) : "–";
        
        // Update status to SAFE with authentic data
        const statusEl = document.getElementById("safetyStatus");
        statusEl.textContent = "SAFE";
        statusEl.style.backgroundColor = "#28A745";
        statusEl.style.color = "white";
        statusEl.title = "Environmental conditions monitored";
        
        console.log("Dashboard updated successfully");
      }).catch(error => {
        console.log("Data fetch error:", error);
      });
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 9. Create professional weather map overlays using free services
    // ─────────────────────────────────────────────────────────────────────────────
    async function createColormapOverlay(layerType) {
      if (currentOverlay) {
        map.removeLayer(currentOverlay);
        currentOverlay = null;
      }

      if (layerType === "none") {
        showLegend("none");
        return;
      }

      setLoading(true);

      // Create detailed pixelated weather visualization using authentic data
      await createDetailedPixelVisualization(layerType);

      showLegend(layerType);
      setLoading(false);
    }

    // Removed weather tile system - using authentic data visualization only

    // Create detailed pixelated weather visualization using authentic Open-Meteo data
    async function createDetailedPixelVisualization(layerType) {
      const scheme = colorSchemes[layerType];
      const bounds = map.getBounds();
      
      // Create fine grid for pixelated patterns
      const gridPoints = generatePixelGrid(bounds);
      currentOverlay = L.layerGroup().addTo(map);
      
      // Process grid points in batches to avoid overwhelming the API
      const batchSize = 4;
      for (let i = 0; i < gridPoints.length; i += batchSize) {
        const batch = gridPoints.slice(i, i + batchSize);
        
        const batchResults = await Promise.all(batch.map(async (point) => {
          try {
            const data = await fetchClimateData(point.lat, point.lon);
            let value;
            
            switch (layerType) {
              case "heat":
                value = data.hi;
                break;
              case "uv":
                value = data.uv;
                break;
              case "pm25":
                value = data.pm25;
                break;
              case "wind":
                value = data.wind;
                break;
            }
            
            return { lat: point.lat, lon: point.lon, value: value };
          } catch (err) {
            return null;
          }
        }));
        
        // Add small rectangular pixels for contour-like visualization
        batchResults.forEach(result => {
          if (result && result.value !== null) {
            const color = getColorForValue(result.value, scheme);
            const pixel = L.rectangle([
              [result.lat - 0.005, result.lon - 0.005],
              [result.lat + 0.005, result.lon + 0.005]
            ], {
              color: color,
              fillColor: color,
              fillOpacity: 0.8,
              weight: 0,
              stroke: false
            }).bindPopup(`${scheme.title}: ${result.value.toFixed(1)}${scheme.unit}`);
            
            currentOverlay.addLayer(pixel);
          }
        });
        
        // Brief pause between batches
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    // Generate fine pixel grid for detailed visualization
    function generatePixelGrid(bounds) {
      const points = [];
      const latRange = bounds.getNorth() - bounds.getSouth();
      const lonRange = bounds.getEast() - bounds.getWest();
      
      // Create 12x12 grid for detailed pixelated appearance
      const gridSize = 12;
      const latStep = latRange / gridSize;
      const lonStep = lonRange / gridSize;
      
      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          points.push({
            lat: bounds.getSouth() + (latStep * i),
            lon: bounds.getWest() + (lonStep * j)
          });
        }
      }
      
      return points;
    }

    // Create accurate Heat Index map using authentic Open-Meteo data
    async function createAccurateHeatIndexMap(layerType) {
      const scheme = colorSchemes[layerType];
      const bounds = map.getBounds();
      
      // Create fine-grained grid for detailed heat index patterns
      const gridPoints = generateDetailedGrid(bounds);
      currentOverlay = L.layerGroup().addTo(map);
      
      // Process grid points in small batches
      const batchSize = 3;
      for (let i = 0; i < gridPoints.length; i += batchSize) {
        const batch = gridPoints.slice(i, i + batchSize);
        
        const batchResults = await Promise.all(batch.map(async (point) => {
          try {
            const data = await fetchClimateData(point.lat, point.lon);
            return { lat: point.lat, lon: point.lon, value: data.hi };
          } catch (err) {
            return null;
          }
        }));
        
        // Add small, overlapping circles for smooth heat index visualization
        batchResults.forEach(result => {
          if (result && result.value !== null) {
            const color = getColorForValue(result.value, scheme);
            const circle = L.circle([result.lat, result.lon], {
              color: color,
              fillColor: color,
              fillOpacity: 0.6,
              radius: 8000, // Small radius for fine detail
              weight: 0,
              stroke: false
            }).bindPopup(`Heat Index: ${result.value.toFixed(1)}°F`);
            
            currentOverlay.addLayer(circle);
          }
        });
        
        // Small delay between batches
        await new Promise(resolve => setTimeout(resolve, 150));
      }
    }
    
    // Generate detailed grid for heat index mapping
    function generateDetailedGrid(bounds) {
      const points = [];
      const latRange = bounds.getNorth() - bounds.getSouth();
      const lonRange = bounds.getEast() - bounds.getWest();
      
      // Create 8x8 grid for good detail without too many API calls
      const gridSize = 8;
      const latStep = latRange / gridSize;
      const lonStep = lonRange / gridSize;
      
      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          points.push({
            lat: bounds.getSouth() + (latStep * i),
            lon: bounds.getWest() + (lonStep * j)
          });
        }
      }
      
      return points;
    }

    // Fallback visualization if weather tiles are unavailable
    async function createFallbackVisualization(layerType) {
      const scheme = colorSchemes[layerType];
      const keyLocations = getKeyLocationsInView();
      currentOverlay = L.layerGroup().addTo(map);

      for (const location of keyLocations) {
        try {
          const data = await fetchClimateData(location.lat, location.lon);
          let value;
          
          switch (layerType) {
            case "heat":
              value = data.hi;
              break;
            case "uv":
              value = data.uv;
              break;
            case "pm25":
              value = data.pm25;
              break;
            case "wind":
              value = data.wind;
              break;
          }

          if (value !== null && value !== undefined) {
            const color = getColorForValue(value, scheme);
            const circle = L.circle([location.lat, location.lon], {
              color: color,
              fillColor: color,
              fillOpacity: 0.7,
              radius: 40000,
              weight: 2,
              stroke: true
            }).bindPopup(`${location.name}: ${scheme.title} ${value.toFixed(1)}`);
            
            currentOverlay.addLayer(circle);
          }
        } catch (err) {
          console.warn("Data fetch failed for location:", location.name);
        }
      }
    }
    
    // Generate efficient grid for contour mapping
    function generateContourGrid(bounds) {
      const points = [];
      const latRange = bounds.getNorth() - bounds.getSouth();
      const lonRange = bounds.getEast() - bounds.getWest();
      
      // Create 4x4 grid for efficiency
      const gridSize = 4;
      const latStep = latRange / gridSize;
      const lonStep = lonRange / gridSize;
      
      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          points.push({
            lat: bounds.getSouth() + (latStep * i),
            lon: bounds.getWest() + (lonStep * j)
          });
        }
      }
      
      return points;
    }
    
    // Create smooth contour visualization from weather data points
    function createContourVisualization(weatherData, layerType, scheme) {
      if (weatherData.length === 0) return;
      
      // Create smooth gradient zones using Voronoi-style regions
      weatherData.forEach(dataPoint => {
        const color = getColorForValue(dataPoint.value, scheme);
        
        // Create large, overlapping circles for smooth gradients
        const circle = L.circle([dataPoint.lat, dataPoint.lon], {
          color: color,
          fillColor: color,
          fillOpacity: 0.4, // Lower opacity for blending
          radius: 80000, // Large radius for smooth transitions
          weight: 0,
          stroke: false
        }).bindPopup(`${scheme.title}: ${dataPoint.value.toFixed(1)}`);
        
        currentOverlay.addLayer(circle);
      });
      
      // Add wind arrows for wind layer
      if (layerType === "wind") {
        addWindArrows(weatherData);
      }
      
      // Add contour lines for temperature
      if (layerType === "heat") {
        addTemperatureContours(weatherData, scheme);
      }
    }
    
    // Add wind direction arrows
    function addWindArrows(weatherData) {
      weatherData.forEach(dataPoint => {
        // Create wind direction indicators (simplified as speed-based arrows)
        const windSpeed = dataPoint.value;
        if (windSpeed > 5) { // Only show arrows for significant wind
          const arrowSize = Math.min(windSpeed / 2, 15);
          const arrow = L.marker([dataPoint.lat, dataPoint.lon], {
            icon: L.divIcon({
              html: `<div style="font-size:${arrowSize}px;color:#333;">→</div>`,
              className: 'wind-arrow',
              iconSize: [arrowSize, arrowSize]
            })
          });
          currentOverlay.addLayer(arrow);
        }
      });
    }
    
    // Add temperature contour lines
    function addTemperatureContours(weatherData, scheme) {
      // Group data by temperature ranges and create contour-like boundaries
      const tempRanges = scheme.ranges;
      tempRanges.forEach(range => {
        const pointsInRange = weatherData.filter(d => 
          d.value >= range.min && d.value < range.max
        );
        
        if (pointsInRange.length > 1) {
          // Create boundary lines between temperature zones
          pointsInRange.forEach((point, i) => {
            if (i < pointsInRange.length - 1) {
              const nextPoint = pointsInRange[i + 1];
              const line = L.polyline([
                [point.lat, point.lon],
                [nextPoint.lat, nextPoint.lon]
              ], {
                color: range.color,
                weight: 2,
                opacity: 0.6,
                dashArray: '5, 5'
              });
              currentOverlay.addLayer(line);
            }
          });
        }
      });
    }

    // Get strategic key locations based on current map view
    function getKeyLocationsInView() {
      const bounds = map.getBounds();
      const center = map.getCenter();
      
      // Define major cities and strategic points for the current region
      const allLocations = [
        { name: "Seattle", lat: 47.6062, lon: -122.3321 },
        { name: "Portland", lat: 45.5152, lon: -122.6784 },
        { name: "Vancouver", lat: 45.6387, lon: -122.6615 },
        { name: "Spokane", lat: 47.6587, lon: -117.4260 },
        { name: "Eugene", lat: 44.0521, lon: -123.0868 },
        { name: "Tacoma", lat: 47.2529, lon: -122.4443 },
        { name: "Salem", lat: 44.9429, lon: -123.0351 },
        { name: "Boise", lat: 43.6150, lon: -116.2023 },
        { name: "Missoula", lat: 46.8721, lon: -113.9940 },
        { name: "Bend", lat: 44.0582, lon: -121.3153 }
      ];

      // Filter locations that are within or near the current view
      return allLocations.filter(location => {
        const latInRange = location.lat >= bounds.getSouth() - 2 && location.lat <= bounds.getNorth() + 2;
        const lonInRange = location.lon >= bounds.getWest() - 2 && location.lon <= bounds.getEast() + 2;
        return latInRange && lonInRange;
      }).slice(0, 8); // Limit to 8 locations for efficiency
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 10. Layer control event handlers
    // ─────────────────────────────────────────────────────────────────────────────
    document.addEventListener("DOMContentLoaded", () => {
      const layerControls = document.querySelectorAll('input[name="layer"]');
      layerControls.forEach(control => {
        control.addEventListener("change", (e) => {
          if (e.target.checked) {
            createColormapOverlay(e.target.value);
          }
        });
      });

      // Focus on US button
      document.getElementById('focus-us').addEventListener('click', () => {
        map.setView([39.8283, -98.5795], 4); // Center of continental US
      });
    });

    // ─────────────────────────────────────────────────────────────────────────────
    // 11. On‐click event: get lat/lon and update
    // ─────────────────────────────────────────────────────────────────────────────
    map.on("click", (e) => {
      const { lat, lng } = e.latlng;
      updateAt(lat, lng);
    });

    // Enhanced location search using Google Maps geocoding
    async function searchLocation(query) {
      if (!query.trim()) return;
      
      try {
        // Use Google Maps geocoding for more accurate results
        const response = await fetch(`/api/geocode?address=${encodeURIComponent(query)}`);
        const data = await response.json();
        
        if (data.results && data.results.length > 0) {
          const location = data.results[0].geometry.location;
          const lat = location.lat;
          const lon = location.lng;
          
          // Check if location is within US bounds
          if (isWithinUSBoundaries(lat, lon)) {
            // Update search box with formatted address
            const formattedAddress = data.results[0].formatted_address;
            document.getElementById("locationSearch").value = formattedAddress;
            updateAt(lat, lon);
          } else {
            alert("Location not found in US territory. Please search for US addresses or cities.");
          }
        } else {
          alert("Location not found. Please try a different search term.");
        }
      } catch (error) {
        console.error("Geocoding error:", error);
        // Fallback to Nominatim if Google API fails
        try {
          const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=us&limit=1`);
          const results = await response.json();
          
          if (results.length > 0) {
            const lat = parseFloat(results[0].lat);
            const lon = parseFloat(results[0].lon);
            
            if (isWithinUSBoundaries(lat, lon)) {
              updateAt(lat, lon);
            } else {
              alert("Location not found in US territory. Please search for US addresses or cities.");
            }
          } else {
            alert("Location not found. Please try a different search term.");
          }
        } catch (fallbackError) {
          alert("Unable to search location. Please try again.");
        }
      }
    }

    // Search button click handler
    document.getElementById("searchLocation").addEventListener("click", () => {
      const query = document.getElementById("locationSearch").value;
      searchLocation(query);
    });

    // Autocomplete functionality
    let autocompleteTimeout;
    
    function showAutocomplete(suggestions) {
      const resultsDiv = document.getElementById("autocompleteResults");
      resultsDiv.innerHTML = "";
      
      if (suggestions.length === 0) {
        resultsDiv.style.display = "none";
        return;
      }
      
      suggestions.forEach(suggestion => {
        const item = document.createElement("div");
        item.style.cssText = "padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f1f3f4; font-size: 14px; transition: background-color 0.2s ease;";
        item.textContent = suggestion.description;
        
        item.addEventListener("mouseenter", () => {
          item.style.backgroundColor = "#f8f9fa";
        });
        
        item.addEventListener("mouseleave", () => {
          item.style.backgroundColor = "white";
        });
        
        item.addEventListener("click", () => {
          document.getElementById("locationSearch").value = suggestion.description;
          hideAutocomplete();
          searchLocation(suggestion.description);
        });
        
        resultsDiv.appendChild(item);
      });
      
      resultsDiv.style.display = "block";
    }
    
    function hideAutocomplete() {
      document.getElementById("autocompleteResults").style.display = "none";
    }
    
    async function fetchAutocomplete(input) {
      if (input.length < 2) {
        hideAutocomplete();
        return;
      }
      
      try {
        // Use Google Places Autocomplete API
        const response = await fetch(`/api/geocode?address=${encodeURIComponent(input)}`);
        const data = await response.json();
        
        if (data.results && data.results.length > 0) {
          // Format results to show multiple matches
          const suggestions = data.results.slice(0, 5).map(result => ({
            description: result.formatted_address,
            place_id: result.place_id
          }));
          
          showAutocomplete(suggestions);
        } else {
          // Fallback to basic US cities autocomplete
          const commonCities = [
            "New York, NY", "Los Angeles, CA", "Chicago, IL", "Houston, TX", 
            "Phoenix, AZ", "Philadelphia, PA", "San Antonio, TX", "San Diego, CA",
            "Dallas, TX", "San Jose, CA", "Austin, TX", "Jacksonville, FL",
            "Fort Worth, TX", "Columbus, OH", "Charlotte, NC", "San Francisco, CA",
            "Indianapolis, IN", "Seattle, WA", "Denver, CO", "Washington, DC",
            "Boston, MA", "El Paso, TX", "Nashville, TN", "Detroit, MI",
            "Oklahoma City, OK", "Portland, OR", "Las Vegas, NV", "Memphis, TN",
            "Louisville, KY", "Baltimore, MD", "Milwaukee, WI", "Albuquerque, NM",
            "Tucson, AZ", "Fresno, CA", "Mesa, AZ", "Sacramento, CA",
            "Atlanta, GA", "Kansas City, MO", "Colorado Springs, CO", "Miami, FL",
            "Raleigh, NC", "Omaha, NE", "Long Beach, CA", "Virginia Beach, VA",
            "Oakland, CA", "Minneapolis, MN", "Tampa, FL", "Arlington, TX",
            "New Orleans, LA", "Wichita, KS", "Cleveland, OH", "Tulsa, OK",
            "Bakersfield, CA", "Aurora, CO", "Anaheim, CA", "Honolulu, HI",
            "Santa Ana, CA", "Corpus Christi, TX", "Riverside, CA", "Lexington, KY",
            "Stockton, CA", "Henderson, NV", "Saint Paul, MN", "St. Louis, MO",
            "Cincinnati, OH", "Pittsburgh, PA", "Greensboro, NC", "Anchorage, AK",
            "Plano, TX", "Lincoln, NE", "Orlando, FL", "Irvine, CA",
            "Newark, NJ", "Durham, NC", "Chula Vista, CA", "Toledo, OH",
            "Fort Wayne, IN", "St. Petersburg, FL", "Laredo, TX", "Jersey City, NJ",
            "Chandler, AZ", "Madison, WI", "Lubbock, TX", "Scottsdale, AZ",
            "Reno, NV", "Buffalo, NY", "Gilbert, AZ", "Glendale, AZ",
            "North Las Vegas, NV", "Winston-Salem, NC", "Chesapeake, VA", "Norfolk, VA",
            "Fremont, CA", "Garland, TX", "Irving, TX", "Hialeah, FL",
            "Richmond, VA", "Boise, ID", "Spokane, WA", "Baton Rouge, LA"
          ];
          
          const filtered = commonCities.filter(city => 
            city.toLowerCase().includes(input.toLowerCase())
          ).slice(0, 5);
          
          const suggestions = filtered.map(city => ({
            description: city
          }));
          
          showAutocomplete(suggestions);
        }
      } catch (error) {
        console.error("Autocomplete error:", error);
        hideAutocomplete();
      }
    }

    // Input handler for autocomplete
    document.getElementById("locationSearch").addEventListener("input", (e) => {
      clearTimeout(autocompleteTimeout);
      autocompleteTimeout = setTimeout(() => {
        fetchAutocomplete(e.target.value);
      }, 300);
    });

    // Enter key handler for search input
    document.getElementById("locationSearch").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        const query = document.getElementById("locationSearch").value;
        hideAutocomplete();
        searchLocation(query);
      }
    });

    // Focus on US button functionality - show Continental US prominently
    document.getElementById("focus-us").addEventListener("click", () => {
      // Focus on Continental US bounds for better presentation
      map.fitBounds([
        [24.0, -125.0], // Southwest (California/Texas)
        [49.0, -66.0]   // Northeast (Maine/Minnesota)
      ]);
    });

    // ─────────────────────────────────────────────────────────────────────────────
    // 12. On‐load: attempt to get user's geolocation; otherwise, show instructions
    // ─────────────────────────────────────────────────────────────────────────────
    window.addEventListener("load", () => {
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            updateAt(pos.coords.latitude, pos.coords.longitude);
          },
          (err) => {
            console.warn("Geolocation denied or unavailable", err);
            // Just leave default map; ask user to click
          }
        );
      }
    });
  </script>
</body>
</html>
