<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Safety Dashboard - Real-time Environmental Hazards</title>

  <!-- Leaflet CSS -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    crossorigin=""
  />
  <!-- Google Fonts -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600&display=swap" rel="stylesheet">

  <style>
    body,
    html {
      margin: 0;
      padding: 0;
      height: 100%;
      font-family: Arial, sans-serif;
    }
    #map {
      width: 100%;
      height: 100%;
    }
    #info {
      position: absolute;
      bottom: 20px;
      left: 20px;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(20px);
      padding: 16px;
      border-radius: 12px;
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.15);
      max-width: 320px;
      z-index: 1000;
      display: none;
      border: 1px solid rgba(255, 255, 255, 0.3);
    }
    #controls {
      position: absolute;
      top: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: none;
    }
    #legend {
      position: absolute;
      bottom: 50px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 10px;
      border-radius: 5px;
      box-shadow: 0 0 6px rgba(0, 0, 0, 0.3);
      z-index: 1000;
      display: none;
    }
    .legend-item {
      display: flex;
      align-items: center;
      margin: 3px 0;
      font-size: 12px;
    }
    .legend-color {
      width: 20px;
      height: 12px;
      margin-right: 5px;
      border: 1px solid #333;
    }
    #info h2 {
      margin: 0 0 8px;
      font-size: 16px;
    }
    #info p {
      margin: 4px 0;
      font-size: 14px;
    }
    #loading {
      position: absolute;
      bottom: 10px;
      left: 10px;
      background: rgba(255, 255, 255, 0.9);
      padding: 6px 10px;
      border-radius: 5px;
      font-size: 13px;
      box-shadow: 0 0 4px rgba(0, 0, 0, 0.2);
      z-index: 1000;
    }

    /* Custom needle marker styling */
    .needle-marker {
      background: none !important;
      border: none !important;
    }
    
    .needle-pin {
      width: 12px;
      height: 32px;
      position: relative;
      transform: translate(-50%, -100%);
    }
    
    .needle-pin::before {
      content: '';
      position: absolute;
      bottom: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 0;
      height: 0;
      border-left: 6px solid transparent;
      border-right: 6px solid transparent;
      border-top: 20px solid #2196F3;
    }
    
    .needle-pin::after {
      content: '';
      position: absolute;
      top: 0;
      left: 50%;
      transform: translateX(-50%);
      width: 8px;
      height: 8px;
      background: #2196F3;
      border-radius: 50%;
      border: 2px solid white;
      box-shadow: 0 2px 4px rgba(0,0,0,0.3);
    }

    /* Emergency alert animation */
    @keyframes pulse {
      0% { opacity: 1; transform: scale(1); }
      50% { opacity: 0.8; transform: scale(1.02); }
      100% { opacity: 1; transform: scale(1); }
    }

    /* Control buttons for all screen sizes */
    .mobile-controls {
      position: fixed;
      top: 20px;
      right: 16px;
      z-index: 1002;
      display: flex;
      flex-direction: column;
      gap: 12px;
      width: auto;
      height: auto;
      max-height: calc(100vh - 40px);
      overflow: visible;
      background: transparent;
      padding: 0;
      border-radius: 0;
      box-shadow: none;
    }
    
    .control-btn {
      width: 56px;
      height: 56px;
      border: none;
      border-radius: 16px;
      font-size: 22px;
      cursor: pointer;
      background: rgba(255, 255, 255, 0.95);
      backdrop-filter: blur(24px);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.12);
      transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      border: 1px solid rgba(255, 255, 255, 0.2);
      flex-shrink: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      position: relative;
      overflow: hidden;
    }
    
    .control-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: linear-gradient(135deg, rgba(103, 126, 234, 0.1) 0%, rgba(118, 75, 162, 0.1) 100%);
      opacity: 0;
      transition: opacity 0.3s ease;
    }
    
    /* NWS button styling */
    #nwsBtn {
      background: rgba(255, 255, 255, 0.95);
      border-color: #ddd;
    }
    
    #nwsBtn:hover {
      background: rgba(255, 140, 0, 1);
      transform: scale(1.1);
    }
    
    #nwsBtn.active {
      background: linear-gradient(135deg, #3498db 0%, #2980b9 100%) !important;
      color: white !important;
      border-color: #2980b9 !important;
    }
    
    .control-btn:hover {
      transform: translateY(-4px) scale(1.08);
      box-shadow: 0 12px 40px rgba(0, 0, 0, 0.18);
    }
    
    .control-btn:hover::before {
      opacity: 1;
    }
    
    .control-btn:active {
      transform: translateY(-2px) scale(1.05);
    }
    
    .control-btn.active {
      background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
      color: white;
      transform: scale(1.1);
      box-shadow: 0 8px 32px rgba(103, 126, 234, 0.4);
    }
    
    .control-btn.active::before {
      display: none;
    }

    /* Advanced mobile optimizations */
    @media (max-width: 768px) {
      /* Enable smooth scrolling physics */
      * {
        -webkit-overflow-scrolling: touch;
        scroll-behavior: smooth;
      }
      
      /* Add pull-to-refresh styling */
      .pull-refresh-indicator {
        position: fixed;
        top: 80px;
        left: 50%;
        transform: translateX(-50%) translateY(-100px);
        background: rgba(33, 150, 243, 0.9);
        color: white;
        padding: 12px 24px;
        border-radius: 25px;
        font-size: 14px;
        font-weight: 600;
        z-index: 1003;
        opacity: 0;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        backdrop-filter: blur(20px);
        box-shadow: 0 8px 32px rgba(33, 150, 243, 0.3);
      }
      
      .pull-refresh-indicator.visible {
        opacity: 1;
        transform: translateX(-50%) translateY(0);
      }
      
      .container {
        flex-direction: column;
        height: 100vh;
        touch-action: pan-x pan-y;
      }
      
      .left-panel {
        position: fixed;
        top: 80px;
        left: 20px;
        right: 80px;
        height: auto;
        max-height: 70vh;
        z-index: 1000;
        background: rgba(255, 255, 255, 0.98);
        backdrop-filter: blur(20px);
        box-shadow: 0 8px 32px rgba(0,0,0,0.15);
        transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        overflow-y: auto;
        border-radius: 16px;
        transform: translateY(-120%);
        opacity: 0;
        pointer-events: none;
      }
      
      .left-panel.visible {
        transform: translateY(0);
        opacity: 1;
        pointer-events: all;
      }
      
      .mobile-header {
        display: none;
      }
      
      .mobile-header h1 {
        margin: 0;
        font-size: 20px;
        font-weight: 700;
        letter-spacing: -0.5px;
      }
      
      .toggle-btn {
        background: rgba(255,255,255,0.15);
        border: 2px solid rgba(255, 255, 255, 0.2);
        color: white;
        font-size: 18px;
        padding: 12px 16px;
        border-radius: 14px;
        cursor: pointer;
        transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
        backdrop-filter: blur(20px);
        font-weight: 300;
        min-width: 44px;
        height: 44px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .toggle-btn:hover {
        background: rgba(255,255,255,0.3);
        transform: scale(1.05);
      }
      
      .toggle-btn:active {
        transform: scale(0.95);
      }
      

      
      .mobile-panel {
        display: none;
      }
      
      .mobile-panel.visible {
        transform: translateY(0);
        opacity: 1;
        pointer-events: all;
      }
      
      .panel-content {
        padding: 24px;
      }
      
      .panel-content h3 {
        margin: 0 0 16px 0;
        color: #2c3e50;
        font-size: 18px;
        font-weight: 600;
      }
      
      .status-display {
        padding: 12px 16px;
        border-radius: 8px;
        margin-bottom: 16px;
        text-align: center;
        font-weight: 500;
        background: #f8f9fa;
        color: #495057;
      }
      
      .right-panel {
        width: 100%;
        height: 100vh;
        margin-top: 0;
        transition: all 0.4s cubic-bezier(0.25, 0.46, 0.45, 0.94);
      }
      
      .left-panel:not(.collapsed) + .right-panel {
        margin-left: 0;
      }
      
      /* Overlay for when panel is open */
      .panel-overlay {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.5);
        z-index: 999;
        opacity: 0;
        visibility: hidden;
        transition: all 0.3s ease;
      }
      
      .left-panel:not(.collapsed) ~ .panel-overlay {
        opacity: 1;
        visibility: visible;
      }
      
      .navigation-panel, .dashboard-panel {
        margin-bottom: 0;
        border-radius: 0;
        border: none;
        padding: 24px;
        background: transparent;
      }
      
      .navigation-panel h3, .dashboard-panel h2 {
        font-size: 18px;
        margin-bottom: 16px;
        color: #2c3e50;
        font-weight: 600;
        letter-spacing: -0.3px;
      }
      
      .navigation-panel {
        border-bottom: 1px solid rgba(0,0,0,0.08);
      }
      
      .search-container input {
        font-size: 16px;
        padding: 16px 20px;
        border-radius: 16px;
        border: 2px solid #E3F2FD;
        background: rgba(255, 255, 255, 0.9);
        backdrop-filter: blur(10px);
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.08);
        width: 100%;
        box-sizing: border-box;
      }
      
      .search-container input:focus {
        border-color: #2196F3;
        box-shadow: 0 0 0 4px rgba(33, 150, 243, 0.1), 0 4px 16px rgba(0, 0, 0, 0.12);
        background: white;
        outline: none;
      }
      
      .search-container button {
        padding: 16px 24px;
        border-radius: 16px;
        background: linear-gradient(135deg, #4CAF50 0%, #388E3C 100%);
        border: none;
        color: white;
        font-size: 16px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        box-shadow: 0 4px 16px rgba(76, 175, 80, 0.3);
        margin-top: 12px;
        width: 100%;
      }
      
      .search-container button:hover {
        transform: translateY(-2px);
        box-shadow: 0 8px 24px rgba(76, 175, 80, 0.4);
      }
      
      .search-container button:active {
        transform: translateY(0);
      }
      
      .weather-card {
        margin-bottom: 16px;
        border-radius: 20px;
        background: rgba(255, 255, 255, 0.95);
        backdrop-filter: blur(20px);
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        border: 1px solid rgba(255, 255, 255, 0.2);
        overflow: hidden;
        transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      }
      
      .weather-card:hover {
        transform: translateY(-2px);
        box-shadow: 0 12px 40px rgba(0, 0, 0, 0.15);
      }
      
      .temp-display {
        font-size: 24px;
        font-weight: 700;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        -webkit-background-clip: text;
        -webkit-text-fill-color: transparent;
        background-clip: text;
      }
      
      .activity-section, .health-section {
        font-size: 12px;
        padding: 12px 16px;
        background: rgba(103, 126, 234, 0.05);
        border-radius: 12px;
        margin: 8px 0;
        border-left: 4px solid #667eea;
      }
      
      /* Hide desktop elements on mobile */
      .desktop-only {
        display: none !important;
      }
    }
    
    /* Custom popup styling */
    .custom-popup .leaflet-popup-content-wrapper {
      border-radius: 8px;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
      max-width: 320px !important;
    }
    
    .custom-popup .leaflet-popup-tip {
      background: white;
      border: none;
      box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .custom-popup .leaflet-popup-content {
      margin: 0;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <!-- Mobile Header - Removed to prevent map blocking -->
  
  <div id="controls">
    <h3 style="margin: 0 0 10px; font-size: 14px;">Navigation</h3>
    <div style="margin-bottom: 12px; position: relative;">
      <input type="text" id="locationSearch" placeholder="Enter city, state or address..." style="padding: 12px 16px; width: 240px; border: 2px solid #e1e5e9; border-radius: 8px; font-size: 14px; font-family: 'Inter', sans-serif; transition: all 0.2s ease; outline: none; background: rgba(255, 255, 255, 0.9);" onfocus="this.style.borderColor='#007cbb'; this.style.boxShadow='0 0 0 3px rgba(0, 124, 187, 0.1)'" onblur="setTimeout(() => {this.style.borderColor='#e1e5e9'; this.style.boxShadow='none'; hideAutocomplete();}, 200)">
      <div id="autocompleteResults" style="position: absolute; top: 100%; left: 0; right: 0; background: white; border: 2px solid #e1e5e9; border-top: none; border-radius: 0 0 8px 8px; max-height: 200px; overflow-y: auto; display: none; z-index: 1001; box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);"></div>
      <button id="searchLocation" style="padding: 12px 16px; background: linear-gradient(135deg, #28a745, #20c997); color: white; border: none; border-radius: 8px; cursor: pointer; margin-left: 8px; font-weight: 500; font-size: 14px; transition: all 0.2s ease; box-shadow: 0 2px 8px rgba(40, 167, 69, 0.3);" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(40, 167, 69, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(40, 167, 69, 0.3)'">Search</button>
    </div>
    <button id="focus-us" style="padding: 12px 16px; background: linear-gradient(135deg, #007cbb, #0056b3); color: white; border: none; border-radius: 8px; cursor: pointer; font-weight: 500; font-size: 14px; transition: all 0.2s ease; width: 100%; box-shadow: 0 2px 8px rgba(0, 124, 187, 0.3);" onmouseover="this.style.transform='translateY(-1px)'; this.style.boxShadow='0 4px 12px rgba(0, 124, 187, 0.4)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 2px 8px rgba(0, 124, 187, 0.3)'">Focus on US Territory</button>
  </div>

  <div id="legend">
    <h4 style="margin: 0 0 8px; font-size: 12px;" id="legendTitle">Legend</h4>
    <div id="legendContent"></div>
  </div>

  <!-- Mobile Control Buttons -->
  <div class="mobile-controls" id="mobileControls">
    <button class="control-btn" onclick="toggleNavigation()" id="navBtn">🧭</button>
    <button class="control-btn" onclick="toggleDashboard()" id="dashBtn">📊</button>
    <button class="control-btn" onclick="toggleFires()" id="fireBtn">🔥</button>
    <button class="control-btn" onclick="toggleNWSAlerts()" id="nwsBtn" title="NWS Alerts">⚠️</button>
  </div>
  
  <script>
    // Debug NWS button visibility
    document.addEventListener('DOMContentLoaded', function() {
      setTimeout(() => {
        const nwsBtn = document.getElementById('nwsBtn');
        const mobileControls = document.getElementById('mobileControls');
        console.log('=== NWS BUTTON DEBUG ===');
        console.log('NWS Button exists:', !!nwsBtn);
        console.log('Mobile controls exists:', !!mobileControls);
        console.log('Total buttons in mobile-controls:', mobileControls ? mobileControls.children.length : 0);
        
        if (nwsBtn) {
          const rect = nwsBtn.getBoundingClientRect();
          console.log('Button position:', rect);
          console.log('Button visible:', rect.width > 0 && rect.height > 0);
          console.log('Button styles:', window.getComputedStyle(nwsBtn));
          
          // Force red background for testing
          nwsBtn.style.background = 'red !important';
          nwsBtn.style.border = '5px solid blue !important';
          nwsBtn.style.width = '60px !important';
          nwsBtn.style.height = '60px !important';
          console.log('Applied force styles to NWS button');
        }
      }, 1000);
    });
  </script>

  
  <!-- Panel Overlay for Mobile -->
  <div class="panel-overlay" onclick="closeAllPanels()"></div>
  
  <!-- Mobile Dashboard Panel - Removed to prevent map blocking -->
  
  <div id="info">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
      <h2 style="margin: 0; font-size: 16px;">Safety Dashboard</h2>
      <button id="toggleDashboard" style="background: #007cbb; color: white; border: none; padding: 4px 8px; border-radius: 3px; cursor: pointer; font-size: 11px;">Minimize</button>
    </div>
    
    <div id="safetyStatus" style="padding: 6px; border-radius: 4px; margin-bottom: 8px; font-weight: bold; text-align: center; font-size: 14px; transition: all 0.3s ease;">
      Click on US territory for environmental data
    </div>
    
    <div id="emergencyAlert" style="display: none; background: #ff4444; color: white; padding: 8px; border-radius: 4px; margin-bottom: 8px; text-align: center; font-weight: bold; animation: pulse 2s infinite;">
      ⚠️ EMERGENCY CONDITIONS DETECTED
    </div>
    
    <div id="dashboardContent">
      <!-- Compact Weather Header -->
      <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 10px; border-radius: 6px; margin-bottom: 6px;">
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; font-size: 12px;">
          <div style="font-weight: bold;">📍 Current Location</div>
          <div style="opacity: 0.9;">Updated: <span id="lastUpdate">--</span></div>
        </div>
        
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
          <div>
            <div style="font-size: 20px; font-weight: bold;"><span id="currentTemp">--</span>°F</div>
            <div style="font-size: 10px; opacity: 0.9;">Feels <span id="hi">--</span>°F</div>
          </div>
          <div style="text-align: center;">
            <div>AQI: <span id="pm25">--</span> (<span id="aqiLevel">--</span>)</div>
            <div>UV: <span id="uv">--</span> (<span id="uvLevel">--</span>)</div>
          </div>
          <div style="text-align: right; font-size: 11px;">
            <div><span style="font-size: 14px;">💨</span> <span id="wind">--</span> mph</div>
            <div><span style="font-size: 14px;">👁️</span> <span id="visibility">--</span> mi</div>
          </div>
        </div>
        
        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 8px; font-size: 10px; text-align: center;">
          <div>H/L: <span id="tempHigh">--</span>°/<span id="tempLow">--</span>°</div>
          <div><span style="font-size: 12px;">💧</span> <span id="humidity">--</span>%</div>
          <div><span style="font-size: 12px;">☁️</span> <span id="cloudCover">--</span>%</div>
        </div>
      </div>

      <!-- Alert Banner -->
      <div id="alertBanner" style="display: none; background: #ff6b35; color: white; padding: 8px; border-radius: 4px; margin-bottom: 8px; font-weight: bold; text-align: center;">
        ⚠️ <span id="alertText">No active alerts</span>
      </div>

      <!-- Compact Activity & Forecast Section -->
      <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-bottom: 6px;">
        <div style="background: #f8f9fa; padding: 6px; border-radius: 4px; font-size: 10px;">
          <div style="font-weight: bold; margin-bottom: 2px;">Good for:</div>
          <div id="goodForActivities"><span style="font-size: 14px;">🚶‍♂️🏃‍♀️🐕</span></div>
        </div>
        <div style="background: #fff3cd; padding: 6px; border-radius: 4px; font-size: 10px;">
          <div style="font-weight: bold; margin-bottom: 2px;">Health Risks:</div>
          <div id="riskForGroups">None</div>
        </div>
      </div>

      <!-- Compact Forecast -->
      <div style="background: #e8f4f8; padding: 6px; border-radius: 4px; font-size: 10px; margin-bottom: 6px;">
        <div>Next Hour: <span id="nextHourForecast">Clear conditions</span></div>
        <div>Next 24h: <span id="next24hForecast">Partly cloudy</span></div>
      </div>
      
      <details style="margin: 4px 0;">
        <summary style="cursor: pointer; font-size: 12px; font-weight: bold; color: #E67E22;">🔥 Fire & Weather Risk</summary>
        <div style="padding: 4px 0; font-size: 11px;">
          <div>Fire Risk: <span id="fireRiskLevel" style="font-weight: bold;">––</span></div>
          <div>Humidity: <span id="humidityValue">––</span>%</div>
          <div>Precipitation: <span id="precipitationValue">––</span> mm</div>
        </div>
      </details>
      
      <details style="margin: 4px 0;">
        <summary style="cursor: pointer; font-size: 12px; font-weight: bold; color: #2980B9;">🌊 Environmental</summary>
        <div style="padding: 4px 0; font-size: 11px;">
          <div>Visibility: <span id="visibilityValue">––</span> miles</div>
          <div>Cloud Cover: <span id="cloudCoverValue">––</span>%</div>
          <div>Pressure: <span id="pressureValue">––</span> hPa</div>
        </div>
      </details>
      
      <details style="margin: 4px 0;">
        <summary style="cursor: pointer; font-size: 12px; font-weight: bold; color: #95A5A6;">❄️ Temperature & Snow</summary>
        <div style="padding: 4px 0; font-size: 11px;">
          <div>Temperature: <span id="temperatureValue">––</span>°F</div>
          <div>Snow Depth: <span id="snowDepthValue">––</span> cm</div>
        </div>
      </details>
    </div>
    
    <div id="safetyRecommendations" style="margin-top: 8px; padding: 6px; background: #f0f8ff; border-radius: 4px; font-size: 10px; display: none;">
      <div id="safetyAdvice"></div>
    </div>
    
    <div id="emergencyActions" style="margin-top: 8px; padding: 6px; background: #fff3cd; border-radius: 4px; font-size: 10px; display: none;">
      <strong>Immediate Actions:</strong>
      <div id="actionList"></div>
    </div>
    
    <div id="minimizedView" style="display: none;">
      <div style="display: flex; gap: 8px; font-size: 11px;">
        <span>🌡️<span id="hiMin">––</span></span>
        <span>☀️<span id="uvMin">––</span></span>
        <span>🌫️<span id="pm25Min">––</span></span>
        <span>💨<span id="windMin">––</span></span>
      </div>
    </div>
    
    <p style="font-size: 10px; color: #666; margin: 8px 0 0; text-align: center;">
      Click any location for detailed safety data
    </p>
  </div>
  <div id="loading" style="display:none">Loading…</div>

  <!-- Leaflet JS -->
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    crossorigin=""
  ></script>
  <script src="https://unpkg.com/@turf/turf@6/turf.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>

  <script>
    // ─────────────────────────────────────────────────────────────────────────────
    // 1. Initialize map with auto-refresh functionality
    // ─────────────────────────────────────────────────────────────────────────────
    const map = L.map("map", {
      // Focus on Continental US bounds only
      maxBounds: [
        [20.0, -130.0], // Southwest corner (southern California/Texas)
        [50.0, -65.0]   // Northeast corner (Maine/Minnesota)
      ],
      maxBoundsViscosity: 1.0,
      minZoom: 3,
      maxZoom: 12
    }).setView([39.5, -98.35], 4); // Default: center of contiguous USA

    // Auto-refresh data every 15 minutes as required
    let currentLocation = null;
    setInterval(() => {
      if (currentLocation) {
        console.log("Auto-refreshing weather data...");
        updateAt(currentLocation.lat, currentLocation.lng);
      }
    }, 15 * 60 * 1000); // 15 minutes

    // Add standard OpenStreetMap tiles
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
      maxZoom: 19,
      attribution: '© OpenStreetMap contributors | Data: NASA FIRMS, OpenWeatherMap, NOAA NWS, Google Maps'
    }).addTo(map);

    // Simple US-focused map without complex boundary loading

    let marker = null;
    let currentOverlay = null;
    let stormMarkers = [];
    let stormMarkersVisible = false;

    // Dashboard toggle functionality
    document.getElementById('toggleDashboard').addEventListener('click', function() {
      const content = document.getElementById('dashboardContent');
      const minimized = document.getElementById('minimizedView');
      const button = this;
      
      if (content.style.display === 'none') {
        content.style.display = 'block';
        minimized.style.display = 'none';
        button.textContent = 'Minimize';
      } else {
        content.style.display = 'none';
        minimized.style.display = 'block';
        button.textContent = 'Expand';
      }
    });

    // Utility to show/hide loading indicator
    function setLoading(show) {
      document.getElementById("loading").style.display = show ? "block" : "none";
    }

    // Color schemes for different hazard types
    const colorSchemes = {
      heat: {
        title: "Heat Index (°F)",
        ranges: [
          { min: 0, max: 80, color: "#00ff00", label: "Safe (< 80°F)" },
          { min: 80, max: 90, color: "#ffff00", label: "Caution (80-90°F)" },
          { min: 90, max: 105, color: "#ff8800", label: "Extreme Caution (90-105°F)" },
          { min: 105, max: 130, color: "#ff0000", label: "Danger (105-130°F)" },
          { min: 130, max: 200, color: "#8b0000", label: "Extreme Danger (>130°F)" }
        ]
      },
      uv: {
        title: "UV Index",
        ranges: [
          { min: 0, max: 2, color: "#00ff00", label: "Low (0-2)" },
          { min: 2, max: 5, color: "#ffff00", label: "Moderate (3-5)" },
          { min: 5, max: 7, color: "#ff8800", label: "High (6-7)" },
          { min: 7, max: 10, color: "#ff0000", label: "Very High (8-10)" },
          { min: 10, max: 20, color: "#8b0000", label: "Extreme (11+)" }
        ]
      },
      pm25: {
        title: "PM₂.₅ (µg/m³)",
        ranges: [
          { min: 0, max: 12, color: "#00ff00", label: "Good (0-12)" },
          { min: 12, max: 35.4, color: "#ffff00", label: "Moderate (12-35)" },
          { min: 35.4, max: 55.4, color: "#ff8800", label: "Unhealthy SG (35-55)" },
          { min: 55.4, max: 150.4, color: "#ff0000", label: "Unhealthy (55-150)" },
          { min: 150.4, max: 500, color: "#8b0000", label: "Hazardous (150+)" }
        ]
      },
      wind: {
        title: "Wind Speed (mph)",
        ranges: [
          { min: 0, max: 15, color: "#00ff00", label: "Light (0-15 mph)" },
          { min: 15, max: 25, color: "#ffff00", label: "Moderate (15-25 mph)" },
          { min: 25, max: 39, color: "#ff8800", label: "Strong (25-39 mph)" },
          { min: 39, max: 54, color: "#ff0000", label: "Gale (39-54 mph)" },
          { min: 54, max: 200, color: "#8b0000", label: "Storm (54+ mph)" }
        ]
      }
    };

    // Generate strategic grid points for colormap overlay
    function generateGridPoints(bounds, resolution = 20) {
      const points = [];
      // Create a more focused grid that covers key areas
      const latRange = bounds.north - bounds.south;
      const lonRange = bounds.east - bounds.west;
      
      // Only create points if the area is reasonable size
      if (latRange > 0.1 && lonRange > 0.1) {
        const latStep = latRange / Math.min(resolution, 8); // Limit to max 8x8 grid
        const lonStep = lonRange / Math.min(resolution, 8);
        
        for (let i = 1; i < Math.min(resolution, 8); i++) {
          for (let j = 1; j < Math.min(resolution, 8); j++) {
            const lat = bounds.south + (latStep * i);
            const lon = bounds.west + (lonStep * j);
            points.push({ lat, lon });
          }
        }
      }
      return points;
    }

    // Get color for value based on scheme
    function getColorForValue(value, scheme) {
      for (const range of scheme.ranges) {
        if (value >= range.min && value < range.max) {
          return range.color;
        }
      }
      return scheme.ranges[scheme.ranges.length - 1].color;
    }

    // Create and display legend
    function showLegend(layerType) {
      const legend = document.getElementById("legend");
      const title = document.getElementById("legendTitle");
      const content = document.getElementById("legendContent");
      
      if (layerType === "none") {
        legend.style.display = "none";
        return;
      }
      
      const scheme = colorSchemes[layerType];
      title.textContent = scheme.title;
      content.innerHTML = "";
      
      scheme.ranges.forEach(range => {
        const item = document.createElement("div");
        item.className = "legend-item";
        item.innerHTML = `
          <div class="legend-color" style="background-color: ${range.color}"></div>
          <span>${range.label}</span>
        `;
        content.appendChild(item);
      });
      
      legend.style.display = "block";
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 2. Helper: Compute Heat Index (°F) from T (°F) and RH (%)
    // NOAA formula: returns HI in °F
    // Source: https://www.wpc.ncep.noaa.gov/html/heatindex_equation.shtml
    // ─────────────────────────────────────────────────────────────────────────────
    function computeHeatIndex(tF, rh) {
      // Only valid if tF >= 80°F and RH >= 40%; otherwise return tF
      if (tF < 80 || rh < 40) return tF.toFixed(1);

      const T = tF,
        R = rh;
      const HI =
        -42.379 +
        2.04901523 * T +
        10.14333127 * R -
        0.22475541 * T * R -
        6.83783e-3 * T * T -
        5.481717e-2 * R * R +
        1.22874e-3 * T * T * R +
        8.5282e-4 * T * R * R -
        1.99e-6 * T * T * R * R;
      return HI.toFixed(1);
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 3. Helper: Map PM2.5 to simplistic category
    // Based on US EPA breakpoints:
    //  0–12 → Good; 12.1–35.4 → Moderate; 35.5–55.4 → Unhealthy for Sensitive Groups; etc.
    // ─────────────────────────────────────────────────────────────────────────────
    function categorizePM25(val) {
      if (val <= 12) return "Good";
      if (val <= 35.4) return "Moderate";
      if (val <= 55.4) return "Unhealthy (SG)";
      if (val <= 150.4) return "Unhealthy";
      if (val <= 250.4) return "Very Unhealthy";
      return "Hazardous";
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 4. Helper: Categorize UV Index and provide safety recommendations
    // ─────────────────────────────────────────────────────────────────────────────
    function categorizeUV(val) {
      if (val <= 2) return { level: "Low", warning: "🟢 Minimal risk" };
      if (val <= 5) return { level: "Moderate", warning: "🟡 Wear sunscreen" };
      if (val <= 7) return { level: "High", warning: "🟠 Seek shade, wear protection" };
      if (val <= 10) return { level: "Very High", warning: "🔴 Avoid sun 10AM-4PM" };
      return { level: "Extreme", warning: "🟣 DANGER: Stay indoors" };
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 5. Helper: Assess heat safety based on Heat Index
    // ─────────────────────────────────────────────────────────────────────────────
    function assessHeatSafety(hi) {
      if (hi < 80) return { level: "Safe", warning: "" };
      if (hi < 90) return { level: "Caution", warning: "🟡 Stay hydrated" };
      if (hi < 105) return { level: "Extreme Caution", warning: "🟠 Limit outdoor activity" };
      if (hi < 130) return { level: "Danger", warning: "🔴 Heat exhaustion likely" };
      return { level: "Extreme Danger", warning: "🟣 HEAT STROKE IMMINENT" };
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 6. Helper: Calculate overall safety status
    // ─────────────────────────────────────────────────────────────────────────────
    function calculateSafetyStatus(hi, uv, pm25, wind, visibility) {
      const risks = [];
      
      if (hi >= 105) risks.push("Heat Danger");
      if (uv > 7) risks.push("UV Extreme");
      if (pm25 > 55.4) risks.push("Air Quality Unhealthy");
      if (wind > 39) risks.push("High Winds");
      if (visibility < 3) risks.push("Low Visibility");
      
      if (risks.length === 0) return { status: "SAFE", color: "#4CAF50", message: "Conditions are safe" };
      if (risks.length <= 2) return { status: "CAUTION", color: "#FF9800", message: `Watch for: ${risks.join(", ")}` };
      return { status: "DANGER", color: "#F44336", message: `Multiple hazards: ${risks.join(", ")}` };
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 7. Fetch safety data - switches to demo mode if API limit reached
    // ─────────────────────────────────────────────────────────────────────────────
    async function fetchClimateData(lat, lon) {
      // Show loading
      setLoading(true);

      const proxyUrl = `/api/weather?lat=${lat}&lon=${lon}`;

      try {
        console.log("Fetching weather data for:", lat, lon);
        
        const response = await fetch(proxyUrl);

        if (!response.ok) {
          // If API fails (likely quota exceeded), show demonstration data
          if (response.status === 500 || response.status === 401) {
            console.log("API quota likely exceeded, showing demo data");
            setLoading(false);
            return generateDemoData(lat, lon);
          }
          throw new Error(`API request failed: ${response.status}`);
        }

        const data = await response.json();
        setLoading(false);
        
        console.log("API Response:", data);
        console.log("Mapped data:", { 
          hi: data.heat_index, 
          pm25: data.pm25, 
          uv: data.uv_index, 
          wind: data.wind_speed, 
          visibility: data.visibility 
        });

        return data;
      } catch (err) {
        setLoading(false);
        console.log("API unavailable, showing demo data");
        return generateDemoData(lat, lon);
      }
    }

    // Generate realistic demo data based on location
    function generateDemoData(lat, lon) {
      // Simulate realistic values based on geographic patterns
      const tempBase = 70 + (lat < 40 ? 15 : 0) + (lat > 50 ? -10 : 0);
      const humidity = 45 + Math.random() * 30;
      const heatIndex = computeHeatIndex(tempBase + Math.random() * 20, humidity);
      
      return {
        hi: heatIndex,
        pm25: 8 + Math.random() * 25, // Typical range
        uv: Math.max(0, 3 + Math.random() * 8), // 0-11 scale
        wind: 5 + Math.random() * 15, // mph
        visibility: 8 + Math.random() * 7 // miles
      };
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // Calculate overall safety status based on all environmental factors
    // ─────────────────────────────────────────────────────────────────────────────
    function calculateSafetyStatus(heatIndex, uvIndex, pm25, windSpeed, visibility) {
      let riskScore = 0;
      let warnings = [];

      // Heat Index assessment
      if (heatIndex >= 130) {
        riskScore += 4; warnings.push("Extreme heat danger");
      } else if (heatIndex >= 105) {
        riskScore += 3; warnings.push("Heat danger");
      } else if (heatIndex >= 90) {
        riskScore += 2; warnings.push("Heat caution");
      }

      // UV Index assessment
      if (uvIndex >= 11) {
        riskScore += 3; warnings.push("Extreme UV");
      } else if (uvIndex >= 8) {
        riskScore += 2; warnings.push("Very high UV");
      } else if (uvIndex >= 6) {
        riskScore += 1; warnings.push("High UV");
      }

      // Air Quality assessment
      if (pm25 >= 150) {
        riskScore += 4; warnings.push("Hazardous air quality");
      } else if (pm25 >= 55) {
        riskScore += 3; warnings.push("Unhealthy air");
      } else if (pm25 >= 35) {
        riskScore += 2; warnings.push("Poor air quality");
      } else if (pm25 >= 12) {
        riskScore += 1; warnings.push("Moderate air quality");
      }

      // Wind assessment
      if (windSpeed >= 54) {
        riskScore += 3; warnings.push("Storm-force winds");
      } else if (windSpeed >= 39) {
        riskScore += 2; warnings.push("Gale-force winds");
      } else if (windSpeed >= 25) {
        riskScore += 1; warnings.push("Strong winds");
      }

      // Determine overall status
      if (riskScore >= 8) {
        return { status: "EXTREME RISK", color: "#8B0000", message: warnings.join(", ") };
      } else if (riskScore >= 5) {
        return { status: "HIGH RISK", color: "#FF0000", message: warnings.join(", ") };
      } else if (riskScore >= 3) {
        return { status: "MODERATE RISK", color: "#FF8800", message: warnings.join(", ") };
      } else if (riskScore >= 1) {
        return { status: "LOW RISK", color: "#FFD700", message: warnings.join(", ") };
      } else {
        return { status: "SAFE", color: "#28A745", message: "Environmental conditions are favorable" };
      }
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // Load and display real fire hazards from NASA satellite data
    // ─────────────────────────────────────────────────────────────────────────────
    let fireMarkers = [];
    let healthRiskMarkers = [];
    
    // Add health risk emblems to map based on environmental conditions
    function addHealthRiskEmblems(data, lat, lon) {
      // Clear existing health risk markers
      healthRiskMarkers.forEach(marker => map.removeLayer(marker));
      healthRiskMarkers = [];
      
      const risks = [];
      
      // Heat emergency conditions
      if (data.heat_index >= 130) {
        risks.push({
          icon: '🌡️',
          title: 'EXTREME HEAT EMERGENCY',
          message: `Heat index ${data.heat_index.toFixed(0)}°F - Heat stroke danger`,
          color: '#8B0000'
        });
      } else if (data.heat_index >= 105) {
        risks.push({
          icon: '🔥',
          title: 'Heat Warning',
          message: `Heat index ${data.heat_index.toFixed(0)}°F - Heat exhaustion risk`,
          color: '#FF4500'
        });
      }
      
      // Air quality emergencies
      if (data.pm25 >= 150) {
        risks.push({
          icon: '☣️',
          title: 'HAZARDOUS AIR QUALITY',
          message: `PM2.5: ${data.pm25.toFixed(0)} µg/m³ - Stay indoors`,
          color: '#8B0000'
        });
      } else if (data.pm25 >= 55) {
        risks.push({
          icon: '🌫️',
          title: 'Unhealthy Air Quality',
          message: `PM2.5: ${data.pm25.toFixed(0)} µg/m³ - Limit outdoor activity`,
          color: '#FF4500'
        });
      }
      
      // Severe wind conditions
      if (data.wind_speed >= 54) {
        risks.push({
          icon: '🌪️',
          title: 'STORM-FORCE WINDS',
          message: `${data.wind_speed.toFixed(0)} mph winds - Take shelter`,
          color: '#8B0000'
        });
      } else if (data.wind_speed >= 39) {
        risks.push({
          icon: '💨',
          title: 'Gale-Force Winds',
          message: `${data.wind_speed.toFixed(0)} mph winds - Secure loose objects`,
          color: '#FF6600'
        });
      }
      
      // Extreme UV conditions
      if (data.uv_index >= 11) {
        risks.push({
          icon: '☀️',
          title: 'EXTREME UV WARNING',
          message: `UV Index ${data.uv_index.toFixed(0)} - Stay indoors`,
          color: '#8B0000'
        });
      }
      
      // Add risk markers to map
      risks.forEach((risk, index) => {
        const offset = index * 0.002; // Slight offset for multiple risks
        const riskIcon = L.divIcon({
          className: 'health-risk-marker',
          html: `<div style="background: ${risk.color}; border-radius: 50%; padding: 8px; font-size: 16px; border: 2px solid white; box-shadow: 0 2px 6px rgba(0,0,0,0.3);">${risk.icon}</div>`,
          iconSize: [32, 32],
          iconAnchor: [16, 16]
        });
        
        const riskMarker = L.marker([lat + offset, lon + offset], { icon: riskIcon })
          .bindPopup(`
            <div style="font-size: 12px; max-width: 200px;">
              <strong style="color: ${risk.color};">${risk.title}</strong><br>
              ${risk.message}<br>
              <em>Current location safety alert</em>
            </div>
          `)
          .addTo(map);
        
        healthRiskMarkers.push(riskMarker);
      });
    }
    
    // Storm warning data loading and display
    async function loadStormWarnings() {
      try {
        console.log("Loading severe weather warnings...");
        const response = await fetch('/api/storms');
        
        if (!response.ok) {
          console.log(`Storm API error: ${response.status} ${response.statusText}`);
          return;
        }
        
        const stormData = await response.json();
        console.log("Storm warnings received:", stormData);
        
        // Clear existing storm markers
        stormMarkers.forEach(marker => {
          if (marker && map.hasLayer && map.hasLayer(marker)) {
            map.removeLayer(marker);
          }
        });
        stormMarkers = [];
        
        if (stormData.warnings && stormData.warnings.length > 0) {
          displayStormMarkers(stormData.warnings);
        } else {
          console.log("No active severe weather warnings");
        }
        
      } catch (error) {
        console.error("Error loading storm warnings:", error);
      }
    }
    
    function displayStormMarkers(warnings) {
      warnings.forEach((warning, index) => {
        const properties = warning.properties || {};
        const event = properties.event || 'Weather Alert';
        const areas = properties.areas || '';
        
        let centerLat = 0, centerLng = 0;
        let hasCoordinates = false;
        
        // Handle alerts with geometry coordinates
        if (warning.geometry && warning.geometry.coordinates) {
          const coords = warning.geometry.coordinates;
          if (coords && coords.length > 0) {
            // Check if it's a Point geometry (from server-side area approximation)
            if (warning.geometry.type === 'Point') {
              centerLng = coords[0];
              centerLat = coords[1];
              hasCoordinates = true;
            } else {
              // Handle complex geometries
              let coordCount = 0;
              
              function processCoords(coordArray) {
                if (Array.isArray(coordArray[0])) {
                  coordArray.forEach(coord => processCoords(coord));
                } else if (coordArray.length >= 2) {
                  centerLng += coordArray[0];
                  centerLat += coordArray[1];
                  coordCount++;
                }
              }
              
              processCoords(coords);
              
              if (coordCount > 0) {
                centerLat /= coordCount;
                centerLng /= coordCount;
                hasCoordinates = true;
              }
            }
          }
        }
        
        // Handle alerts without coordinates using area-based positioning
        if (!hasCoordinates && areas) {
          const areaLower = areas.toLowerCase();
          
          // Approximate coordinates for major regions mentioned in alerts
          if (areaLower.includes('portland') || areaLower.includes('willamette') || areaLower.includes('columbia river')) {
            centerLat = 45.52; centerLng = -122.68; // Portland area
          } else if (areaLower.includes('seattle') || areaLower.includes('puget sound')) {
            centerLat = 47.61; centerLng = -122.33; // Seattle area
          } else if (areaLower.includes('spokane')) {
            centerLat = 47.66; centerLng = -117.43; // Spokane area
          } else if (areaLower.includes('yakima')) {
            centerLat = 46.60; centerLng = -120.51; // Yakima area
          } else if (areaLower.includes('el paso')) {
            centerLat = 31.76; centerLng = -106.49; // El Paso area
          } else if (areaLower.includes('texas')) {
            centerLat = 31.25; centerLng = -99.25; // Central Texas
          } else if (areaLower.includes('washington')) {
            centerLat = 47.04; centerLng = -120.84; // Central Washington
          } else if (areaLower.includes('oregon')) {
            centerLat = 44.93; centerLng = -123.03; // Central Oregon
          } else if (areaLower.includes('idaho')) {
            centerLat = 44.07; centerLng = -114.74; // Central Idaho
          } else {
            // Skip if no recognizable area
            return;
          }
          hasCoordinates = true;
        }
        
        if (hasCoordinates) {
          const properties = warning.properties;
        const event = properties.event || 'Weather Alert';
        const severity = properties.severity || 'Unknown';
        const urgency = properties.urgency || 'Unknown';
        const headline = properties.headline || 'Weather Warning';
        const description = properties.description || 'No description available';
        const instruction = properties.instruction || '';
        const areas = properties.areas || '';
        const effective = properties.effective;
        const expires = properties.expires;
        
        // Choose appropriate emoji and color based on NWS event type
        let icon = '⚠️';
        let color = '#FF9800';
        
        const eventLower = event.toLowerCase();
        
        if (eventLower.includes('tornado')) {
          icon = '🌪️';
          color = '#8B0000';
        } else if (eventLower.includes('severe thunderstorm') || eventLower.includes('thunderstorm')) {
          icon = '⛈️';
          color = '#FF4444';
        } else if (eventLower.includes('flash flood') || eventLower.includes('flood')) {
          icon = '🌊';
          color = '#0066CC';
        } else if (eventLower.includes('hurricane')) {
          icon = '🌀';
          color = '#8B0000';
        } else if (eventLower.includes('winter storm') || eventLower.includes('blizzard') || eventLower.includes('ice storm')) {
          icon = '🌨️';
          color = '#4169E1';
        } else if (eventLower.includes('heat')) {
          icon = '🔥';
          color = '#FF4500';
        } else if (eventLower.includes('wind') || eventLower.includes('gale')) {
          icon = '💨';
          color = '#FF6600';
        } else if (eventLower.includes('dust storm')) {
          icon = '💨';
          color = '#D2691E';
        } else if (eventLower.includes('fire') || eventLower.includes('red flag')) {
          icon = '🔥';
          color = '#DC143C';
        } else if (eventLower.includes('freeze') || eventLower.includes('frost')) {
          icon = '❄️';
          color = '#87CEEB';
        } else if (eventLower.includes('dense fog')) {
          icon = '🌫️';
          color = '#696969';
        } else if (eventLower.includes('high surf') || eventLower.includes('coastal flood')) {
          icon = '🌊';
          color = '#1E90FF';
        }
        
        // Adjust color based on severity
        if (severity === 'Extreme') {
          color = '#8B0000';
        } else if (severity === 'Severe') {
          color = '#FF0000';
        } else if (severity === 'Moderate') {
          color = '#FF8C00';
        }
        
        // Format effective and expiry times
        let timeInfo = '';
        if (effective) {
          const effectiveDate = new Date(effective);
          timeInfo += `<strong>Effective:</strong> ${effectiveDate.toLocaleString()}<br>`;
        }
        if (expires) {
          const expiresDate = new Date(expires);
          timeInfo += `<strong>Expires:</strong> ${expiresDate.toLocaleString()}<br>`;
        }
        
        const stormMarker = L.marker([centerLat, centerLng], {
          icon: L.divIcon({
            html: `<div style="background: ${color}; color: white; border-radius: 50%; width: 32px; height: 32px; display: flex; align-items: center; justify-content: center; font-size: 18px; border: 2px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4);">${icon}</div>`,
            className: 'nws-alert-marker',
            iconSize: [32, 32],
            iconAnchor: [16, 16]
          })
        })
        .on('click', function() {
          // Display alert info in bottom left panel instead of popup
          showWeatherAlertInfo(event, severity, urgency, headline, description, instruction, areas, timeInfo, color);
        })
        .addTo(map);
        
        stormMarkers.push(stormMarker);
        }
      });
      
      console.log(`Displayed ${warnings.length} NWS alerts on map`);
    }
    
    // Auto-refresh storm warnings every 5 minutes when visible
    setInterval(() => {
      if (stormMarkersVisible) {
        console.log("Auto-refreshing storm warnings...");
        loadStormWarnings();
      }
    }, 5 * 60 * 1000); // 5 minutes for rapid storm development
    
    // Global fire data cache to prevent losing markers on navigation
    let cachedFireData = null;
    let lastFireDataFetch = 0;
    const FIRE_CACHE_DURATION = 5 * 60 * 1000; // 5 minutes

    async function loadFireHazards() {
      try {
        const now = Date.now();
        
        // Use cached data if available and recent
        if (cachedFireData && (now - lastFireDataFetch) < FIRE_CACHE_DURATION) {
          displayFireMarkers(cachedFireData);
          return;
        }
        
        console.log("Requesting fire data from server...");
        const response = await fetch('/api/fires');
        
        if (!response.ok) {
          console.log(`Fire API error: ${response.status} ${response.statusText}`);
          // Keep existing markers if API fails
          if (cachedFireData) {
            console.log("Using cached fire data due to API error");
            displayFireMarkers(cachedFireData);
          }
          return;
        }
        
        const fireData = await response.json();
        console.log("Fire data response:", fireData);
        
        if (!fireData.fires || fireData.fires.length === 0) {
          console.log("No active fires detected in response");
          // Keep existing markers if no new data
          if (cachedFireData) {
            displayFireMarkers(cachedFireData);
          }
          return;
        }
        
        // Cache successful fire data
        cachedFireData = fireData;
        lastFireDataFetch = now;
        
        console.log(`Loading ${fireData.count} active fires from NASA satellite data`);
        displayFireMarkers(fireData);
        
      } catch (error) {
        console.log("Fire data service unavailable");
        // Keep existing markers on error
        if (cachedFireData) {
          displayFireMarkers(cachedFireData);
        }
      }
    }

    function displayFireMarkers(fireData) {
      // Clear existing fire markers
      fireMarkers.forEach(marker => map.removeLayer(marker));
      fireMarkers = [];
      
      // Add fire markers to map
      fireData.fires.forEach(fire => {
        const fireIcon = L.divIcon({
          className: 'fire-marker',
          html: '🔥',
          iconSize: [20, 20],
          iconAnchor: [10, 10]
        });
        
        const fireMarker = L.marker([fire.latitude, fire.longitude], { icon: fireIcon })
          .bindPopup(`
            <div style="font-size: 12px;">
              <strong>Active Fire Detected</strong><br>
              Confidence: ${fire.confidence}<br>
              Brightness: ${fire.brightness}K<br>
              Date: ${fire.acq_date}<br>
              Time: ${fire.acq_time}<br>
              <em>Source: NASA FIRMS Satellite</em>
            </div>
          `)
          .addTo(map);
        
        fireMarkers.push(fireMarker);
      });
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // Mobile control functionality
    // ─────────────────────────────────────────────────────────────────────────────
    let fireMarkersVisible = true;
    
    function toggleNavigation() {
      const controls = document.getElementById('controls');
      const navBtn = document.getElementById('navBtn');
      const dashboardPanel = document.getElementById('mobile-dashboard');
      const dashBtn = document.getElementById('dashBtn');
      const info = document.getElementById('info');
      
      // Close dashboard if open
      if (dashboardPanel && dashboardPanel.classList.contains('visible')) {
        dashboardPanel.classList.remove('visible');
        if (dashBtn) dashBtn.classList.remove('active');
      }
      
      // Close info panel if open
      if (info && info.style.display === 'block') {
        info.style.display = 'none';
      }
      
      if (controls && controls.style.display === 'block') {
        controls.style.display = 'none';
        if (navBtn) navBtn.classList.remove('active');
      } else {
        if (controls) controls.style.display = 'block';
        if (navBtn) navBtn.classList.add('active');
      }
    }
    
    function toggleDashboard() {
      const info = document.getElementById('info');
      const dashBtn = document.getElementById('dashBtn');
      const controls = document.getElementById('controls');
      const navBtn = document.getElementById('navBtn');
      
      // Close navigation if open
      if (controls && controls.style.display === 'block') {
        controls.style.display = 'none';
        if (navBtn) navBtn.classList.remove('active');
      }
      
      if (info && info.style.display === 'block') {
        info.style.display = 'none';
        if (dashBtn) dashBtn.classList.remove('active');
      } else {
        if (info) info.style.display = 'block';
        if (dashBtn) dashBtn.classList.add('active');
      }
    }
    
    function toggleFires() {
      const fireBtn = document.getElementById('fireBtn');
      
      fireMarkersVisible = !fireMarkersVisible;
      
      if (fireMarkersVisible) {
        fireBtn.classList.add('active');
        // Show fire markers
        fireMarkers.forEach(marker => {
          if (marker && map.hasLayer && !map.hasLayer(marker)) {
            map.addLayer(marker);
          }
        });
      } else {
        fireBtn.classList.remove('active');
        // Hide fire markers
        fireMarkers.forEach(marker => {
          if (marker && map.hasLayer && map.hasLayer(marker)) {
            map.removeLayer(marker);
          }
        });
      }
    }
    
    function showWeatherAlertInfo(event, severity, urgency, headline, description, instruction, areas, timeInfo, color) {
      // Create a temporary alert popup instead of overriding the dashboard
      let alertPopup = document.getElementById('alertPopup');
      if (!alertPopup) {
        alertPopup = document.createElement('div');
        alertPopup.id = 'alertPopup';
        alertPopup.style.cssText = `
          position: fixed;
          top: 50%;
          left: 50%;
          transform: translate(-50%, -50%);
          background: white;
          border-radius: 12px;
          box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
          max-width: 400px;
          max-height: 80vh;
          overflow-y: auto;
          z-index: 10000;
          display: none;
        `;
        document.body.appendChild(alertPopup);
      }
      
      alertPopup.innerHTML = `
        <div style="font-size: 12px;">
          <div style="background: ${color}; color: white; padding: 12px; border-radius: 12px 12px 0 0; position: relative;">
            <button onclick="document.getElementById('alertPopup').style.display='none'" style="position: absolute; top: 8px; right: 8px; background: rgba(255,255,255,0.2); border: none; color: white; border-radius: 50%; width: 24px; height: 24px; cursor: pointer;">×</button>
            <strong style="font-size: 14px;">${event}</strong>
            <div style="font-size: 11px; opacity: 0.9; margin-top: 4px;">${areas}</div>
          </div>
          
          <div style="padding: 12px;">
            <div style="margin-bottom: 8px;">
              <strong>Severity:</strong> ${severity} | <strong>Urgency:</strong> ${urgency}
            </div>
            
            ${timeInfo}
            
            <div style="margin: 8px 0;">
              <strong>Headline:</strong><br>
              <em style="line-height: 1.3;">${headline}</em>
            </div>
            
            <div style="max-height: 150px; overflow-y: auto; margin: 8px 0; padding: 8px; background: #f8f9fa; border-radius: 6px; line-height: 1.4;">
              <strong>Description:</strong><br>
              ${description.substring(0, 600)}${description.length > 600 ? '...' : ''}
            </div>
            
            ${instruction ? `
              <div style="margin: 8px 0; padding: 8px; background: #fff3cd; border-radius: 6px; border-left: 4px solid #ffc107; line-height: 1.3;">
                <strong>Instructions:</strong><br>
                ${instruction.substring(0, 400)}${instruction.length > 400 ? '...' : ''}
              </div>
            ` : ''}
            
            <div style="margin-top: 12px; font-size: 10px; color: #666; text-align: center;">
              <em>Source: National Weather Service</em>
            </div>
          </div>
        </div>
      `;
      
      alertPopup.style.display = 'block';
    }
    
    function toggleNWSAlerts() {
      const nwsBtn = document.getElementById('nwsBtn');
      
      stormMarkersVisible = !stormMarkersVisible;
      
      if (stormMarkersVisible) {
        nwsBtn.classList.add('active');
        // Load and show NWS alerts
        loadStormWarnings();
      } else {
        nwsBtn.classList.remove('active');
        // Hide storm markers only - keep dashboard intact
        stormMarkers.forEach(marker => {
          if (marker && map.hasLayer && map.hasLayer(marker)) {
            map.removeLayer(marker);
          }
        });
        // Close any open alert popup
        const alertPopup = document.getElementById('alertPopup');
        if (alertPopup) {
          alertPopup.style.display = 'none';
        }
      }
    }
    
    function closeAllPanels() {
      const controls = document.getElementById('controls');
      const info = document.getElementById('info');
      const navBtn = document.getElementById('navBtn');
      const dashBtn = document.getElementById('dashBtn');
      const fireBtn = document.getElementById('fireBtn');
      const nwsBtn = document.getElementById('nwsBtn');
      
      if (controls) {
        controls.style.display = 'none';
      }
      
      if (info) {
        info.style.display = 'none';
      }
      
      if (navBtn) {
        navBtn.classList.remove('active');
      }
      
      if (dashBtn) {
        dashBtn.classList.remove('active');
      }
      
      if (fireBtn) {
        fireBtn.classList.remove('active');
      }
      
      if (nwsBtn) {
        nwsBtn.classList.remove('active');
      }
    }
    
    function updateMobileDashboard() {
      const mobileStatus = document.getElementById('mobile-status');
      const mobileWeatherInfo = document.getElementById('mobile-weather-info');
      const mobileActivities = document.getElementById('mobile-activities');
      const currentStatus = document.getElementById('safetyStatus');
      const currentTemp = document.getElementById('temperature');
      const currentActivities = document.getElementById('goodForActivities');
      
      if (mobileStatus && currentStatus) {
        mobileStatus.textContent = currentStatus.textContent;
        mobileStatus.style.backgroundColor = currentStatus.style.backgroundColor;
        mobileStatus.style.color = currentStatus.style.color;
      }
      
      if (mobileWeatherInfo && currentTemp) {
        mobileWeatherInfo.innerHTML = `
          <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
            <span><strong>Temperature:</strong> ${currentTemp.textContent}</span>
            <span><strong>AQI:</strong> ${document.getElementById('aqi').textContent}</span>
          </div>
          <div style="display: flex; justify-content: space-between;">
            <span><strong>UV:</strong> ${document.getElementById('uv').textContent}</span>
            <span><strong>Wind:</strong> ${document.getElementById('wind').textContent}</span>
          </div>
        `;
      }
      
      if (mobileActivities && currentActivities) {
        mobileActivities.innerHTML = `<strong>Good for:</strong> ${currentActivities.textContent}`;
      }
    }

    // Initialize interface
    window.addEventListener('load', () => {
      const fireBtn = document.getElementById('fireBtn');
      
      // Set fires as active by default
      if (fireBtn) fireBtn.classList.add('active');
    });

    // ─────────────────────────────────────────────────────────────────────────────
    // Check if coordinates are within US boundaries using Census data
    // ─────────────────────────────────────────────────────────────────────────────
    function isWithinUSBoundaries(lat, lon) {
      // Only allow lower 48 US states (excluding Alaska, Hawaii, Mexico, Canada)
      if (lat >= 25.0 && lat <= 49.0 && lon >= -125.0 && lon <= -66.0) return true;
      
      return false;
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 8. Place (or move) marker & update comprehensive safety info panel
    // ─────────────────────────────────────────────────────────────────────────────
    function updateAt(lat, lon) {
      // Check if location is within US boundaries
      if (!isWithinUSBoundaries(lat, lon)) {
        alert("Environmental data is only available within US boundaries");
        return;
      }

      // Move map & marker and track location for auto-refresh
      map.setView([lat, lon], 12);
      currentLocation = { lat: lat, lng: lon };
      
      // Create custom needle-style marker
      const needleIcon = L.divIcon({
        className: 'needle-marker',
        html: '<div class="needle-pin"></div>',
        iconSize: [12, 32],
        iconAnchor: [6, 32]
      });
      
      if (marker) marker.setLatLng([lat, lon]);
      else marker = L.marker([lat, lon], { icon: needleIcon }).addTo(map);

      // Load fire hazards on map
      loadFireHazards();

      // Fetch and update dashboard with real environmental data
      fetchClimateData(lat, lon).then(data => {
        console.log("Raw API data received:", data);
        
        // Extract temperature and heat index from API response
        const temp = data.temperature;
        const heatIndex = data.heat_index;
        const humidity = data.humidity;
        const cloudCover = data.cloud_cover;
        
        // Update dashboard elements with robust field mapping
        if (document.getElementById("currentTemp")) {
          document.getElementById("currentTemp").textContent = temp ? temp.toFixed(1) : "–";
        }
        if (document.getElementById("hi")) {
          document.getElementById("hi").textContent = heatIndex ? heatIndex.toFixed(1) : "–";
        }
        if (document.getElementById("tempHigh")) {
          document.getElementById("tempHigh").textContent = data.temp_max ? data.temp_max.toFixed(0) : "–";
        }
        if (document.getElementById("tempLow")) {
          document.getElementById("tempLow").textContent = data.temp_min ? data.temp_min.toFixed(0) : "–";
        }
        if (document.getElementById("humidity")) {
          document.getElementById("humidity").textContent = humidity ? humidity.toFixed(0) : "–";
        }
        if (document.getElementById("cloudCover")) {
          document.getElementById("cloudCover").textContent = cloudCover ? cloudCover.toFixed(0) : "–";
        }
        if (document.getElementById("pm25")) {
          document.getElementById("pm25").textContent = data.pm25 ? data.pm25.toFixed(1) : "–";
        }
        if (document.getElementById("uv")) {
          document.getElementById("uv").textContent = data.uv_index ? data.uv_index.toFixed(1) : "–";
        }
        if (document.getElementById("wind")) {
          document.getElementById("wind").textContent = data.wind_speed ? data.wind_speed.toFixed(1) : "–";
        }
        if (document.getElementById("visibility")) {
          document.getElementById("visibility").textContent = data.visibility ? data.visibility.toFixed(1) : "–";
        }
        
        // Update collapsible section data
        if (document.getElementById("fireRiskLevel")) {
          document.getElementById("fireRiskLevel").textContent = getFireRiskLevel(data.fire_risk || 0);
        }
        if (document.getElementById("humidityValue")) {
          document.getElementById("humidityValue").textContent = humidity ? humidity.toFixed(0) : "–";
        }
        if (document.getElementById("precipitationValue")) {
          document.getElementById("precipitationValue").textContent = data.precipitation ? data.precipitation.toFixed(2) : "0.00";
        }
        if (document.getElementById("visibilityValue")) {
          document.getElementById("visibilityValue").textContent = data.visibility ? data.visibility.toFixed(1) : "–";
        }
        if (document.getElementById("cloudCoverValue")) {
          document.getElementById("cloudCoverValue").textContent = cloudCover ? cloudCover.toFixed(0) : "–";
        }
        if (document.getElementById("pressureValue")) {
          document.getElementById("pressureValue").textContent = data.pressure ? data.pressure.toFixed(0) : "–";
        }
        if (document.getElementById("temperatureValue")) {
          document.getElementById("temperatureValue").textContent = temp ? temp.toFixed(1) : "–";
        }
        if (document.getElementById("snowDepthValue")) {
          document.getElementById("snowDepthValue").textContent = data.snow_depth ? data.snow_depth.toFixed(1) : "0.0";
        }
        
        // Update descriptive levels using correct field names
        if (document.getElementById("aqiLevel")) {
          document.getElementById("aqiLevel").textContent = getAQILevel(data.pm25);
        }
        if (document.getElementById("uvLevel")) {
          document.getElementById("uvLevel").textContent = getUVLevel(data.uv_index);
        }
        
        // Update timestamp
        if (document.getElementById("lastUpdate")) {
          document.getElementById("lastUpdate").textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }
        
        // Check for severe weather conditions and display alerts
        checkSevereWeatherAlerts(data, lat, lon);
        
        // Show wind gusts if significant
        if (data.wind_gusts && data.wind_gusts > data.wind + 5) {
          document.getElementById("windGusts").style.display = "inline";
          document.getElementById("gustSpeed").textContent = data.wind_gusts.toFixed(1);
        } else {
          document.getElementById("windGusts").style.display = "none";
        }
        
        // Update activity recommendations
        updateActivityRecommendations(data);
        
        console.log("Activity recommendations updated with data:", {
          pm25: data.pm25,
          heat_index: data.heat_index,
          uv_index: data.uv_index
        });
        
        // Update forecast preview
        updateForecastPreview(data);
        
        // Calculate comprehensive safety status and provide actionable advice
        const safety = calculateComprehensiveSafety(data);
        const statusEl = document.getElementById("safetyStatus");
        statusEl.textContent = safety.status;
        statusEl.style.backgroundColor = safety.color;
        statusEl.style.color = "white";
        statusEl.title = safety.message;
        
        // Add health risk emblems to map based on conditions
        addHealthRiskEmblems(data, lat, lon);
        
        // Show emergency alert if dangerous conditions
        const alertEl = document.getElementById("emergencyAlert");
        if (safety.emergency) {
          alertEl.style.display = "block";
          alertEl.textContent = safety.emergencyMessage;
        } else {
          alertEl.style.display = "none";
        }
        
        // Provide practical safety recommendations
        updateSafetyGuidance(data);
        
        console.log("Dashboard updated successfully");
      }).catch(error => {
        console.log("Data fetch error:", error);
      });
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 8.4. Weather Icon and Display Functions
    // ─────────────────────────────────────────────────────────────────────────────
    function getAQILevel(pm25) {
      if (pm25 <= 12) return "Good";
      if (pm25 <= 35.4) return "Moderate";
      if (pm25 <= 55.4) return "Unhealthy for Sensitive";
      if (pm25 <= 150.4) return "Unhealthy";
      if (pm25 <= 250.4) return "Very Unhealthy";
      return "Hazardous";
    }

    function getUVLevel(uv) {
      if (uv <= 2) return "Low";
      if (uv <= 5) return "Moderate";
      if (uv <= 7) return "High";
      if (uv <= 10) return "Very High";
      return "Extreme";
    }

    function getFireRiskLevel(risk) {
      if (risk <= 2) return "Low";
      if (risk <= 4) return "Moderate";
      if (risk <= 6) return "High";
      if (risk <= 8) return "Very High";
      return "Extreme";
    }

    function updateActivityRecommendations(data) {
      let goodFor = [];
      let riskFor = [];

      // Use correct field names from API response
      const heatIndex = data.heat_index || data.temperature;
      const uvIndex = data.uv_index || 0;
      const windSpeed = data.wind_speed || 0;
      const pm25Value = data.pm25 || 0;
      
      console.log("Health risk check:", { pm25Value, heatIndex, uvIndex });
      console.log("Risk conditions:", {
        pm25Over35: pm25Value > 35,
        heatOver85: heatIndex > 85, 
        uvOver7: uvIndex > 7
      });

      // Walking/Running recommendations
      if (heatIndex < 85 && pm25Value < 55 && windSpeed < 25) {
        goodFor.push("🚶‍♂️", "🏃‍♀️");
      }

      // Pet walking
      if (heatIndex < 90 && pm25Value < 35) {
        goodFor.push("🐕");
      }

      // Outdoor sports
      if (heatIndex < 80 && uvIndex < 8 && windSpeed < 20) {
        goodFor.push("⚽");
      }

      // Risk groups based on current conditions
      if (pm25Value > 35) {
        riskFor.push("🫁 Asthma/Lung issues");
      }
      if (pm25Value > 35 || heatIndex > 85) {
        riskFor.push("👴 Elderly");
      }
      if (uvIndex > 7) {
        riskFor.push("👶 Children");
      }
      if (pm25Value > 55) {
        riskFor.push("❤️ Heart conditions");
      }
      
      // Add severe weather risks
      if (windSpeed > 39) {
        riskFor.push("🌪️ Severe Winds");
      }
      if (data.precipitation > 0.5) {
        riskFor.push("⛈️ Thunderstorms");
      }
      if (heatIndex > 105) {
        riskFor.push("🌡️ Heat Emergency");
      }

      document.getElementById("goodForActivities").textContent = goodFor.length > 0 ? goodFor.join(" ") : "Limited";
      document.getElementById("riskForGroups").textContent = riskFor.length > 0 ? riskFor.join(", ") : "None";
    }

    function updateForecastPreview(data) {
      let nextHour = "Clear conditions";
      let next24h = "Partly cloudy";

      // Next hour forecast
      if (data.wind > 20) {
        nextHour = "Breezy conditions";
      } else if (data.precipitation_probability > 50) {
        nextHour = "Chance of rain";
      } else if (data.cloud_cover > 70) {
        nextHour = "Cloudy skies";
      }

      // Next 24h forecast
      if (data.precipitation_probability > 30) {
        next24h = "Chance of rain";
      } else if (data.hi > 85) {
        next24h = "Hot conditions expected";
      } else if (data.wind > 15) {
        next24h = "Windy weather";
      }

      document.getElementById("nextHourForecast").textContent = nextHour;
      document.getElementById("next24hForecast").textContent = next24h;
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 8.4. Severe Weather Alerts System
    // ─────────────────────────────────────────────────────────────────────────────
    async function checkSevereWeatherAlerts(data, lat, lon) {
      const alerts = [];
      
      // High wind/storm conditions
      if (data.wind_speed > 40) {
        alerts.push({
          type: 'HIGH_WIND',
          severity: 'WARNING',
          title: 'High Wind Warning',
          description: `Sustained winds ${data.wind_speed.toFixed(0)} mph. Secure loose objects and avoid driving.`
        });
      }
      
      // Extreme heat conditions
      if (data.heat_index >= 105) {
        alerts.push({
          type: 'HEAT_WARNING',
          severity: 'WARNING', 
          title: 'Extreme Heat Warning',
          description: `Heat index ${data.heat_index.toFixed(0)}°F. Heat exhaustion and heat stroke possible.`
        });
      }
      
      // Air quality emergencies
      if (data.pm25 >= 150) {
        alerts.push({
          type: 'AIR_QUALITY',
          severity: 'WARNING',
          title: 'Air Quality Emergency',
          description: 'Hazardous air quality. Stay indoors with windows closed.'
        });
      }
      
      // Display alerts if any exist
      const alertBanner = document.getElementById("alertBanner");
      const alertText = document.getElementById("alertText");
      
      if (alerts.length > 0) {
        const primaryAlert = alerts[0];
        alertBanner.style.display = "block";
        alertText.textContent = `${primaryAlert.title}: ${primaryAlert.description}`;
        
        // Change color based on severity
        if (primaryAlert.severity === 'WARNING') {
          alertBanner.style.background = "#dc3545";
        } else {
          alertBanner.style.background = "#fd7e14";
        }
      } else {
        alertBanner.style.display = "none";
      }
      
      // Try to fetch NOAA weather alerts for this location
      try {
        const response = await fetch(`https://api.weather.gov/alerts/active?point=${lat},${lon}`);
        if (response.ok) {
          const alertData = await response.json();
          if (alertData.features && alertData.features.length > 0) {
            const noaaAlert = alertData.features[0].properties;
            alertBanner.style.display = "block";
            alertBanner.style.background = "#8b0000";
            alertText.textContent = `NWS: ${noaaAlert.headline || noaaAlert.event}`;
          }
        }
      } catch (error) {
        console.log("NOAA alerts unavailable");
      }
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 8.5. Emergency Safety Assessment Functions
    // ─────────────────────────────────────────────────────────────────────────────
    function calculateComprehensiveSafety(data) {
      let riskLevel = 0;
      let warnings = [];
      let emergency = false;
      let emergencyMessage = "";

      // Critical heat danger assessment
      if (data.hi >= 130) {
        riskLevel = 4;
        emergency = true;
        emergencyMessage = "🔥 HEAT STROKE DANGER - SEEK IMMEDIATE SHELTER";
        warnings.push("Extreme heat emergency");
      } else if (data.hi >= 105) {
        riskLevel = 3;
        warnings.push("Heat exhaustion risk");
      } else if (data.hi >= 90) {
        riskLevel = 2;
        warnings.push("Heat caution advised");
      }

      // Air quality emergency levels
      if (data.pm25 >= 250) {
        riskLevel = Math.max(riskLevel, 4);
        emergency = true;
        emergencyMessage = "☣️ HAZARDOUS AIR - STAY INDOORS IMMEDIATELY";
        warnings.push("Air quality emergency");
      } else if (data.pm25 >= 150) {
        riskLevel = Math.max(riskLevel, 3);
        warnings.push("Unhealthy air quality");
      } else if (data.pm25 >= 55.5) {
        riskLevel = Math.max(riskLevel, 2);
        warnings.push("Sensitive groups affected");
      }

      // High wind danger
      if (data.wind >= 74) {
        riskLevel = Math.max(riskLevel, 4);
        emergency = true;
        emergencyMessage = "🌪️ HURRICANE FORCE WINDS - TAKE SHELTER NOW";
        warnings.push("Hurricane force winds");
      } else if (data.wind >= 39) {
        riskLevel = Math.max(riskLevel, 3);
        warnings.push("High wind warning");
      }

      // UV extreme danger
      if (data.uv >= 11) {
        riskLevel = Math.max(riskLevel, 3);
        warnings.push("Extreme UV - avoid sun exposure");
      } else if (data.uv >= 8) {
        riskLevel = Math.max(riskLevel, 2);
        warnings.push("Very high UV");
      }

      // Return comprehensive assessment
      if (riskLevel >= 4) {
        return {
          status: "EMERGENCY",
          color: "#8B0000",
          message: warnings.join(", "),
          emergency: true,
          emergencyMessage: emergencyMessage
        };
      } else if (riskLevel >= 3) {
        return {
          status: "DANGER",
          color: "#FF0000",
          message: warnings.join(", "),
          emergency: false
        };
      } else if (riskLevel >= 2) {
        return {
          status: "CAUTION",
          color: "#FF8800",
          message: warnings.join(", "),
          emergency: false
        };
      } else {
        return {
          status: "SAFE",
          color: "#28A745",
          message: "Environmental conditions are safe",
          emergency: false
        };
      }
    }

    function updateSafetyGuidance(data) {
      let advice = [];
      let actions = [];

      // Heat safety guidance
      if (data.hi >= 105) {
        advice.push("🌡️ Extreme heat detected");
        actions.push("• Move to air-conditioned space immediately");
        actions.push("• Drink water every 15-20 minutes");
        actions.push("• Avoid outdoor activities");
        actions.push("• Watch for heat exhaustion symptoms");
      } else if (data.hi >= 90) {
        advice.push("🌡️ Heat caution needed");
        actions.push("• Limit outdoor exposure during peak hours");
        actions.push("• Stay hydrated - drink before you feel thirsty");
        actions.push("• Wear light-colored, loose clothing");
      }

      // Air quality guidance
      if (data.pm25 >= 150) {
        advice.push("🫁 Hazardous air quality");
        actions.push("• Stay indoors with windows closed");
        actions.push("• Use air purifiers if available");
        actions.push("• Avoid all outdoor exercise");
        actions.push("• Consider N95 masks if you must go outside");
      } else if (data.pm25 >= 55.5) {
        advice.push("🫁 Unhealthy air for sensitive groups");
        actions.push("• Limit outdoor activities if you have heart/lung conditions");
        actions.push("• Keep rescue inhalers accessible");
      }

      // Wind safety guidance
      if (data.wind >= 39) {
        advice.push("💨 High wind warning");
        actions.push("• Secure loose outdoor items");
        actions.push("• Avoid driving high-profile vehicles");
        actions.push("• Stay away from trees and power lines");
      }

      // UV protection guidance
      if (data.uv >= 8) {
        advice.push("☀️ Extreme UV exposure risk");
        actions.push("• Apply SPF 30+ sunscreen every 2 hours");
        actions.push("• Seek shade between 10am-4pm");
        actions.push("• Wear UV-blocking sunglasses and hat");
      }

      // Display guidance if there are recommendations
      const adviceEl = document.getElementById("safetyRecommendations");
      const actionsEl = document.getElementById("emergencyActions");
      
      if (advice.length > 0) {
        adviceEl.style.display = "block";
        document.getElementById("safetyAdvice").innerHTML = advice.join("<br>");
      } else {
        adviceEl.style.display = "none";
      }
      
      if (actions.length > 0) {
        actionsEl.style.display = "block";
        document.getElementById("actionList").innerHTML = actions.join("<br>");
      } else {
        actionsEl.style.display = "none";
      }
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 9. Create professional weather map overlays using free services
    // ─────────────────────────────────────────────────────────────────────────────
    async function createColormapOverlay(layerType) {
      if (currentOverlay) {
        map.removeLayer(currentOverlay);
        currentOverlay = null;
      }

      if (layerType === "none") {
        showLegend("none");
        return;
      }

      setLoading(true);

      // Create detailed pixelated weather visualization using authentic data
      await createDetailedPixelVisualization(layerType);

      showLegend(layerType);
      setLoading(false);
    }

    // Removed weather tile system - using authentic data visualization only

    // Create detailed pixelated weather visualization using authentic Open-Meteo data
    async function createDetailedPixelVisualization(layerType) {
      const scheme = colorSchemes[layerType];
      const bounds = map.getBounds();
      
      // Create fine grid for pixelated patterns
      const gridPoints = generatePixelGrid(bounds);
      currentOverlay = L.layerGroup().addTo(map);
      
      // Process grid points in batches to avoid overwhelming the API
      const batchSize = 4;
      for (let i = 0; i < gridPoints.length; i += batchSize) {
        const batch = gridPoints.slice(i, i + batchSize);
        
        const batchResults = await Promise.all(batch.map(async (point) => {
          try {
            const data = await fetchClimateData(point.lat, point.lon);
            let value;
            
            switch (layerType) {
              case "heat":
                value = data.hi;
                break;
              case "uv":
                value = data.uv;
                break;
              case "pm25":
                value = data.pm25;
                break;
              case "wind":
                value = data.wind;
                break;
            }
            
            return { lat: point.lat, lon: point.lon, value: value };
          } catch (err) {
            return null;
          }
        }));
        
        // Add small rectangular pixels for contour-like visualization
        batchResults.forEach(result => {
          if (result && result.value !== null) {
            const color = getColorForValue(result.value, scheme);
            const pixel = L.rectangle([
              [result.lat - 0.005, result.lon - 0.005],
              [result.lat + 0.005, result.lon + 0.005]
            ], {
              color: color,
              fillColor: color,
              fillOpacity: 0.8,
              weight: 0,
              stroke: false
            }).bindPopup(`${scheme.title}: ${result.value.toFixed(1)}${scheme.unit}`);
            
            currentOverlay.addLayer(pixel);
          }
        });
        
        // Brief pause between batches
        await new Promise(resolve => setTimeout(resolve, 100));
      }
    }
    
    // Generate fine pixel grid for detailed visualization
    function generatePixelGrid(bounds) {
      const points = [];
      const latRange = bounds.getNorth() - bounds.getSouth();
      const lonRange = bounds.getEast() - bounds.getWest();
      
      // Create 12x12 grid for detailed pixelated appearance
      const gridSize = 12;
      const latStep = latRange / gridSize;
      const lonStep = lonRange / gridSize;
      
      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          points.push({
            lat: bounds.getSouth() + (latStep * i),
            lon: bounds.getWest() + (lonStep * j)
          });
        }
      }
      
      return points;
    }

    // Create accurate Heat Index map using authentic Open-Meteo data
    async function createAccurateHeatIndexMap(layerType) {
      const scheme = colorSchemes[layerType];
      const bounds = map.getBounds();
      
      // Create fine-grained grid for detailed heat index patterns
      const gridPoints = generateDetailedGrid(bounds);
      currentOverlay = L.layerGroup().addTo(map);
      
      // Process grid points in small batches
      const batchSize = 3;
      for (let i = 0; i < gridPoints.length; i += batchSize) {
        const batch = gridPoints.slice(i, i + batchSize);
        
        const batchResults = await Promise.all(batch.map(async (point) => {
          try {
            const data = await fetchClimateData(point.lat, point.lon);
            return { lat: point.lat, lon: point.lon, value: data.hi };
          } catch (err) {
            return null;
          }
        }));
        
        // Add small, overlapping circles for smooth heat index visualization
        batchResults.forEach(result => {
          if (result && result.value !== null) {
            const color = getColorForValue(result.value, scheme);
            const circle = L.circle([result.lat, result.lon], {
              color: color,
              fillColor: color,
              fillOpacity: 0.6,
              radius: 8000, // Small radius for fine detail
              weight: 0,
              stroke: false
            }).bindPopup(`Heat Index: ${result.value.toFixed(1)}°F`);
            
            currentOverlay.addLayer(circle);
          }
        });
        
        // Small delay between batches
        await new Promise(resolve => setTimeout(resolve, 150));
      }
    }
    
    // Generate detailed grid for heat index mapping
    function generateDetailedGrid(bounds) {
      const points = [];
      const latRange = bounds.getNorth() - bounds.getSouth();
      const lonRange = bounds.getEast() - bounds.getWest();
      
      // Create 8x8 grid for good detail without too many API calls
      const gridSize = 8;
      const latStep = latRange / gridSize;
      const lonStep = lonRange / gridSize;
      
      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          points.push({
            lat: bounds.getSouth() + (latStep * i),
            lon: bounds.getWest() + (lonStep * j)
          });
        }
      }
      
      return points;
    }

    // Fallback visualization if weather tiles are unavailable
    async function createFallbackVisualization(layerType) {
      const scheme = colorSchemes[layerType];
      const keyLocations = getKeyLocationsInView();
      currentOverlay = L.layerGroup().addTo(map);

      for (const location of keyLocations) {
        try {
          const data = await fetchClimateData(location.lat, location.lon);
          let value;
          
          switch (layerType) {
            case "heat":
              value = data.hi;
              break;
            case "uv":
              value = data.uv;
              break;
            case "pm25":
              value = data.pm25;
              break;
            case "wind":
              value = data.wind;
              break;
          }

          if (value !== null && value !== undefined) {
            const color = getColorForValue(value, scheme);
            const circle = L.circle([location.lat, location.lon], {
              color: color,
              fillColor: color,
              fillOpacity: 0.7,
              radius: 40000,
              weight: 2,
              stroke: true
            }).bindPopup(`${location.name}: ${scheme.title} ${value.toFixed(1)}`);
            
            currentOverlay.addLayer(circle);
          }
        } catch (err) {
          console.warn("Data fetch failed for location:", location.name);
        }
      }
    }
    
    // Generate efficient grid for contour mapping
    function generateContourGrid(bounds) {
      const points = [];
      const latRange = bounds.getNorth() - bounds.getSouth();
      const lonRange = bounds.getEast() - bounds.getWest();
      
      // Create 4x4 grid for efficiency
      const gridSize = 4;
      const latStep = latRange / gridSize;
      const lonStep = lonRange / gridSize;
      
      for (let i = 0; i <= gridSize; i++) {
        for (let j = 0; j <= gridSize; j++) {
          points.push({
            lat: bounds.getSouth() + (latStep * i),
            lon: bounds.getWest() + (lonStep * j)
          });
        }
      }
      
      return points;
    }
    
    // Create smooth contour visualization from weather data points
    function createContourVisualization(weatherData, layerType, scheme) {
      if (weatherData.length === 0) return;
      
      // Create smooth gradient zones using Voronoi-style regions
      weatherData.forEach(dataPoint => {
        const color = getColorForValue(dataPoint.value, scheme);
        
        // Create large, overlapping circles for smooth gradients
        const circle = L.circle([dataPoint.lat, dataPoint.lon], {
          color: color,
          fillColor: color,
          fillOpacity: 0.4, // Lower opacity for blending
          radius: 80000, // Large radius for smooth transitions
          weight: 0,
          stroke: false
        }).bindPopup(`${scheme.title}: ${dataPoint.value.toFixed(1)}`);
        
        currentOverlay.addLayer(circle);
      });
      
      // Add wind arrows for wind layer
      if (layerType === "wind") {
        addWindArrows(weatherData);
      }
      
      // Add contour lines for temperature
      if (layerType === "heat") {
        addTemperatureContours(weatherData, scheme);
      }
    }
    
    // Add wind direction arrows
    function addWindArrows(weatherData) {
      weatherData.forEach(dataPoint => {
        // Create wind direction indicators (simplified as speed-based arrows)
        const windSpeed = dataPoint.value;
        if (windSpeed > 5) { // Only show arrows for significant wind
          const arrowSize = Math.min(windSpeed / 2, 15);
          const arrow = L.marker([dataPoint.lat, dataPoint.lon], {
            icon: L.divIcon({
              html: `<div style="font-size:${arrowSize}px;color:#333;">→</div>`,
              className: 'wind-arrow',
              iconSize: [arrowSize, arrowSize]
            })
          });
          currentOverlay.addLayer(arrow);
        }
      });
    }
    
    // Add temperature contour lines
    function addTemperatureContours(weatherData, scheme) {
      // Group data by temperature ranges and create contour-like boundaries
      const tempRanges = scheme.ranges;
      tempRanges.forEach(range => {
        const pointsInRange = weatherData.filter(d => 
          d.value >= range.min && d.value < range.max
        );
        
        if (pointsInRange.length > 1) {
          // Create boundary lines between temperature zones
          pointsInRange.forEach((point, i) => {
            if (i < pointsInRange.length - 1) {
              const nextPoint = pointsInRange[i + 1];
              const line = L.polyline([
                [point.lat, point.lon],
                [nextPoint.lat, nextPoint.lon]
              ], {
                color: range.color,
                weight: 2,
                opacity: 0.6,
                dashArray: '5, 5'
              });
              currentOverlay.addLayer(line);
            }
          });
        }
      });
    }

    // Get strategic key locations based on current map view
    function getKeyLocationsInView() {
      const bounds = map.getBounds();
      const center = map.getCenter();
      
      // Define major cities and strategic points for the current region
      const allLocations = [
        { name: "Seattle", lat: 47.6062, lon: -122.3321 },
        { name: "Portland", lat: 45.5152, lon: -122.6784 },
        { name: "Vancouver", lat: 45.6387, lon: -122.6615 },
        { name: "Spokane", lat: 47.6587, lon: -117.4260 },
        { name: "Eugene", lat: 44.0521, lon: -123.0868 },
        { name: "Tacoma", lat: 47.2529, lon: -122.4443 },
        { name: "Salem", lat: 44.9429, lon: -123.0351 },
        { name: "Boise", lat: 43.6150, lon: -116.2023 },
        { name: "Missoula", lat: 46.8721, lon: -113.9940 },
        { name: "Bend", lat: 44.0582, lon: -121.3153 }
      ];

      // Filter locations that are within or near the current view
      return allLocations.filter(location => {
        const latInRange = location.lat >= bounds.getSouth() - 2 && location.lat <= bounds.getNorth() + 2;
        const lonInRange = location.lon >= bounds.getWest() - 2 && location.lon <= bounds.getEast() + 2;
        return latInRange && lonInRange;
      }).slice(0, 8); // Limit to 8 locations for efficiency
    }

    // ─────────────────────────────────────────────────────────────────────────────
    // 10. Layer control event handlers
    // ─────────────────────────────────────────────────────────────────────────────
    document.addEventListener("DOMContentLoaded", () => {
      const layerControls = document.querySelectorAll('input[name="layer"]');
      layerControls.forEach(control => {
        control.addEventListener("change", (e) => {
          if (e.target.checked) {
            createColormapOverlay(e.target.value);
          }
        });
      });

      // Focus on US button
      document.getElementById('focus-us').addEventListener('click', () => {
        map.setView([39.8283, -98.5795], 4); // Center of continental US
      });
    });

    // ─────────────────────────────────────────────────────────────────────────────
    // 11. On‐click event: get lat/lon and update
    // ─────────────────────────────────────────────────────────────────────────────
    map.on("click", (e) => {
      const { lat, lng } = e.latlng;
      updateAt(lat, lng);
    });

    // Enhanced location search using Google Maps geocoding
    async function searchLocation(query) {
      if (!query.trim()) return;
      
      try {
        // Use Google Maps geocoding for more accurate results
        const response = await fetch(`/api/geocode?address=${encodeURIComponent(query)}`);
        const data = await response.json();
        
        if (data.results && data.results.length > 0) {
          const location = data.results[0].geometry.location;
          const lat = location.lat;
          const lon = location.lng;
          
          // Check if location is within US bounds
          if (isWithinUSBoundaries(lat, lon)) {
            // Update search box with formatted address
            const formattedAddress = data.results[0].formatted_address;
            document.getElementById("locationSearch").value = formattedAddress;
            updateAt(lat, lon);
          } else {
            alert("Location not found in US territory. Please search for US addresses or cities.");
          }
        } else {
          alert("Location not found. Please try a different search term.");
        }
      } catch (error) {
        console.error("Geocoding error:", error);
        // Fallback to Nominatim if Google API fails
        try {
          const response = await fetch(`https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(query)}&countrycodes=us&limit=1`);
          const results = await response.json();
          
          if (results.length > 0) {
            const lat = parseFloat(results[0].lat);
            const lon = parseFloat(results[0].lon);
            
            if (isWithinUSBoundaries(lat, lon)) {
              updateAt(lat, lon);
            } else {
              alert("Location not found in US territory. Please search for US addresses or cities.");
            }
          } else {
            alert("Location not found. Please try a different search term.");
          }
        } catch (fallbackError) {
          alert("Unable to search location. Please try again.");
        }
      }
    }

    // Search button click handler
    document.getElementById("searchLocation").addEventListener("click", () => {
      const query = document.getElementById("locationSearch").value;
      searchLocation(query);
    });

    // Autocomplete functionality
    let autocompleteTimeout;
    
    function showAutocomplete(suggestions) {
      const resultsDiv = document.getElementById("autocompleteResults");
      resultsDiv.innerHTML = "";
      
      if (suggestions.length === 0) {
        resultsDiv.style.display = "none";
        return;
      }
      
      suggestions.forEach(suggestion => {
        const item = document.createElement("div");
        item.style.cssText = "padding: 12px 16px; cursor: pointer; border-bottom: 1px solid #f1f3f4; font-size: 14px; transition: background-color 0.2s ease;";
        item.textContent = suggestion.description;
        
        item.addEventListener("mouseenter", () => {
          item.style.backgroundColor = "#f8f9fa";
        });
        
        item.addEventListener("mouseleave", () => {
          item.style.backgroundColor = "white";
        });
        
        item.addEventListener("click", () => {
          document.getElementById("locationSearch").value = suggestion.description;
          hideAutocomplete();
          searchLocation(suggestion.description);
        });
        
        resultsDiv.appendChild(item);
      });
      
      resultsDiv.style.display = "block";
    }
    
    function hideAutocomplete() {
      document.getElementById("autocompleteResults").style.display = "none";
    }
    
    async function fetchAutocomplete(input) {
      if (input.length < 2) {
        hideAutocomplete();
        return;
      }
      
      try {
        // Use Google Places Autocomplete API
        const response = await fetch(`/api/geocode?address=${encodeURIComponent(input)}`);
        const data = await response.json();
        
        if (data.results && data.results.length > 0) {
          // Format results to show multiple matches
          const suggestions = data.results.slice(0, 5).map(result => ({
            description: result.formatted_address,
            place_id: result.place_id
          }));
          
          showAutocomplete(suggestions);
        } else {
          // Fallback to basic US cities autocomplete
          const commonCities = [
            "New York, NY", "Los Angeles, CA", "Chicago, IL", "Houston, TX", 
            "Phoenix, AZ", "Philadelphia, PA", "San Antonio, TX", "San Diego, CA",
            "Dallas, TX", "San Jose, CA", "Austin, TX", "Jacksonville, FL",
            "Fort Worth, TX", "Columbus, OH", "Charlotte, NC", "San Francisco, CA",
            "Indianapolis, IN", "Seattle, WA", "Denver, CO", "Washington, DC",
            "Boston, MA", "El Paso, TX", "Nashville, TN", "Detroit, MI",
            "Oklahoma City, OK", "Portland, OR", "Las Vegas, NV", "Memphis, TN",
            "Louisville, KY", "Baltimore, MD", "Milwaukee, WI", "Albuquerque, NM",
            "Tucson, AZ", "Fresno, CA", "Mesa, AZ", "Sacramento, CA",
            "Atlanta, GA", "Kansas City, MO", "Colorado Springs, CO", "Miami, FL",
            "Raleigh, NC", "Omaha, NE", "Long Beach, CA", "Virginia Beach, VA",
            "Oakland, CA", "Minneapolis, MN", "Tampa, FL", "Arlington, TX",
            "New Orleans, LA", "Wichita, KS", "Cleveland, OH", "Tulsa, OK",
            "Bakersfield, CA", "Aurora, CO", "Anaheim, CA", "Honolulu, HI",
            "Santa Ana, CA", "Corpus Christi, TX", "Riverside, CA", "Lexington, KY",
            "Stockton, CA", "Henderson, NV", "Saint Paul, MN", "St. Louis, MO",
            "Cincinnati, OH", "Pittsburgh, PA", "Greensboro, NC", "Anchorage, AK",
            "Plano, TX", "Lincoln, NE", "Orlando, FL", "Irvine, CA",
            "Newark, NJ", "Durham, NC", "Chula Vista, CA", "Toledo, OH",
            "Fort Wayne, IN", "St. Petersburg, FL", "Laredo, TX", "Jersey City, NJ",
            "Chandler, AZ", "Madison, WI", "Lubbock, TX", "Scottsdale, AZ",
            "Reno, NV", "Buffalo, NY", "Gilbert, AZ", "Glendale, AZ",
            "North Las Vegas, NV", "Winston-Salem, NC", "Chesapeake, VA", "Norfolk, VA",
            "Fremont, CA", "Garland, TX", "Irving, TX", "Hialeah, FL",
            "Richmond, VA", "Boise, ID", "Spokane, WA", "Baton Rouge, LA"
          ];
          
          const filtered = commonCities.filter(city => 
            city.toLowerCase().includes(input.toLowerCase())
          ).slice(0, 5);
          
          const suggestions = filtered.map(city => ({
            description: city
          }));
          
          showAutocomplete(suggestions);
        }
      } catch (error) {
        console.error("Autocomplete error:", error);
        hideAutocomplete();
      }
    }

    // Input handler for autocomplete
    document.getElementById("locationSearch").addEventListener("input", (e) => {
      clearTimeout(autocompleteTimeout);
      autocompleteTimeout = setTimeout(() => {
        fetchAutocomplete(e.target.value);
      }, 300);
    });

    // Enter key handler for search input
    document.getElementById("locationSearch").addEventListener("keypress", (e) => {
      if (e.key === "Enter") {
        const query = document.getElementById("locationSearch").value;
        hideAutocomplete();
        searchLocation(query);
      }
    });

    // Focus on US button functionality - show Continental US prominently
    document.getElementById("focus-us").addEventListener("click", () => {
      // Focus on Continental US bounds for better presentation
      map.fitBounds([
        [24.0, -125.0], // Southwest (California/Texas)
        [49.0, -66.0]   // Northeast (Maine/Minnesota)
      ]);
    });

    // ─────────────────────────────────────────────────────────────────────────────
    // 12. On‐load: attempt to get user's geolocation; otherwise, show instructions
    // ─────────────────────────────────────────────────────────────────────────────
    window.addEventListener("load", () => {
      // Load fire hazards immediately when map loads
      loadFireHazards();
      
      if (navigator.geolocation) {
        navigator.geolocation.getCurrentPosition(
          (pos) => {
            updateAt(pos.coords.latitude, pos.coords.longitude);
          },
          (err) => {
            console.warn("Geolocation denied or unavailable", err);
            // Just leave default map; ask user to click
          }
        );
      }
    });
    
    // ─────────────────────────────────────────────────────────────────────────────
    // Enhanced Mobile Interactions
    // ─────────────────────────────────────────────────────────────────────────────
    function initializeMobileEnhancements() {
      if (!window.DeviceMotionEvent && !window.DeviceOrientationEvent) return;
      
      // Add pull-to-refresh indicator
      const refreshIndicator = document.createElement('div');
      refreshIndicator.className = 'pull-refresh-indicator';
      refreshIndicator.textContent = '↓ Pull to refresh data';
      refreshIndicator.id = 'pullRefreshIndicator';
      document.body.appendChild(refreshIndicator);
      
      let startY = 0;
      let isDragging = false;
      let canRefresh = false;
      
      // Touch event handlers for pull-to-refresh
      document.addEventListener('touchstart', (e) => {
        if (window.scrollY === 0) {
          startY = e.touches[0].clientY;
          isDragging = true;
        }
      }, { passive: true });
      
      document.addEventListener('touchmove', (e) => {
        if (!isDragging) return;
        
        const currentY = e.touches[0].clientY;
        const diff = currentY - startY;
        
        if (diff > 80 && window.scrollY === 0) {
          canRefresh = true;
          refreshIndicator.classList.add('visible');
          refreshIndicator.textContent = '↑ Release to refresh';
          
          // Add subtle haptic feedback simulation
          if (navigator.vibrate) {
            navigator.vibrate(10);
          }
        } else if (diff < 50) {
          canRefresh = false;
          refreshIndicator.classList.remove('visible');
          refreshIndicator.textContent = '↓ Pull to refresh data';
        }
      }, { passive: true });
      
      document.addEventListener('touchend', () => {
        if (canRefresh) {
          performDataRefresh();
        }
        isDragging = false;
        canRefresh = false;
        refreshIndicator.classList.remove('visible');
      });
      
      // Enhanced button touch feedback
      const buttons = document.querySelectorAll('.control-btn, .search-container button, .toggle-btn');
      buttons.forEach(button => {
        button.addEventListener('touchstart', (e) => {
          button.style.transform = button.style.transform.replace('scale(1)', 'scale(0.95)');
          if (navigator.vibrate) {
            navigator.vibrate(5);
          }
        }, { passive: true });
        
        button.addEventListener('touchend', (e) => {
          setTimeout(() => {
            button.style.transform = button.style.transform.replace('scale(0.95)', 'scale(1)');
          }, 150);
        }, { passive: true });
      });
    }
    
    async function performDataRefresh() {
      const indicator = document.getElementById('pullRefreshIndicator');
      indicator.textContent = '🔄 Refreshing...';
      indicator.classList.add('visible');
      
      try {
        // Refresh all data sources
        await Promise.all([
          loadFires(),
          currentLocation ? updateAt(currentLocation.lat, currentLocation.lng) : Promise.resolve(),
          stormMarkersVisible ? loadStormWarnings() : Promise.resolve()
        ]);
        
        indicator.textContent = '✓ Data refreshed';
        setTimeout(() => {
          indicator.classList.remove('visible');
        }, 1500);
        
        if (navigator.vibrate) {
          navigator.vibrate([10, 50, 10]);
        }
      } catch (error) {
        indicator.textContent = '✗ Refresh failed';
        setTimeout(() => {
          indicator.classList.remove('visible');
        }, 2000);
      }
    }
    
    // Initialize mobile enhancements when DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeMobileEnhancements);
    } else {
      initializeMobileEnhancements();
    }
    
  </script>
</body>
</html>
